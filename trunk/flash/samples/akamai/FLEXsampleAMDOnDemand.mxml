<?xml version="1.0" encoding="utf-8"?>
<!--
//
// Copyright (c) 2008, the Open Video Player authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without 
// modification, are permitted provided that the following conditions are 
// met:
//
//    * Redistributions of source code must retain the above copyright 
//		notice, this list of conditions and the following disclaimer.
//    * Redistributions in binary form must reproduce the above 
//		copyright notice, this list of conditions and the following 
//		disclaimer in the documentation and/or other materials provided 
//		with the distribution.
//    * Neither the name of the openvideoplayer.org nor the names of its 
//		contributors may be used to endorse or promote products derived 
//		from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
-->
<mx:Application xmlns:mx="http://www.adobe.com/2006/mxml" layout="absolute" creationComplete="init()" viewSourceURL="srcview/index.html">

	<mx:Script>
		<![CDATA[
			import mx.core.UIComponent;
			import mx.events.SliderEvent;
			import mx.controls.Alert;
			
			import org.openvideoplayer.events.*;
			import org.openvideoplayer.net.*;
			
			// Define private variables
			private var _nc:AkamaiConnection;
			private var _ns:OvpNetStream;
			private var _filename:String;
			private var _sliderDragging:Boolean;
			private var _waitForSeek:Boolean;
			private var _video:Video;
			private var _videoHolder:UIComponent;
			private var _streamLength:Number;
			
			// Define functions
			private function init():void {
				_nc = new AkamaiConnection();

				_nc.addEventListener(OvpEvent.ERROR, errorHandler);
				_nc.addEventListener(OvpEvent.BANDWIDTH,bandwidthHandler);
				_nc.addEventListener(OvpEvent.STREAM_LENGTH,streamLengthHandler); 
				_nc.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
								
				addVideoToStage();
					
			}

			// Commences connection to an ondemand stream
			private function startPlayback(hostname:String,streamname:String,authParams:String):void {
				write("Attempting to connect to " + hostname + " ...");
				_filename = streamname;
				if (authParams != "") {
					_nc.connectionAuth = authParams;
				}
				if (_nc.netConnection is NetConnection) {
					_nc.close();
				}
				_nc.connect(currentState == "progressive" ? null:hostname);
			}

			// Once a good connection is found, this handler will be called
			private function connectedHandler():void {
				write("Successfully connected to: " + _nc.netConnection.uri);
				bPlayPause.enabled = true;

				_ns = new OvpNetStream(_nc);
				
				_ns.addEventListener(NetStatusEvent.NET_STATUS,streamStatusHandler);
				_ns.addEventListener(OvpEvent.NETSTREAM_PLAYSTATUS,streamPlayStatusHandler);
				_ns.addEventListener(OvpEvent.NETSTREAM_METADATA,metadataHandler);
				_ns.addEventListener(OvpEvent.NETSTREAM_CUEPOINT,cuepointHandler);
				_ns.addEventListener(OvpEvent.MP3_ID3,id3Handler);
				_ns.addEventListener(OvpEvent.PROGRESS,update);
				_ns.addEventListener(OvpEvent.STREAM_LENGTH,streamLengthHandler); 
				_ns.addEventListener(OvpEvent.ASYNC_ERROR, asyncErrorHandler);
				_ns.addEventListener(OvpEvent.ONFI, onFIHandler);		

				_video.attachNetStream(_ns);
				if (currentState == "progressive") {
					playVideo(_filename);
				} else {
					write("Port: " + _nc.actualPort);
					write("Protocol: " + _nc.actualProtocol);
					write("IP address: " + _nc.serverIPaddress);
					// start the asynchronous process of requesting the stream length
					_nc.requestStreamLength(_filename);
					// start the asynchronous process of estimating bandwidth
					_nc.detectBandwidth();
				}

				
			}
			// Handles all error events
			private function errorHandler(e:OvpEvent):void {
				switch(e.data.errorNumber) {
				case OvpError.STREAM_NOT_FOUND:
					Alert.show("Connected to the server at " + _nc.serverIPaddress + " but timed-out trying to locate the live stream " + _filename, "UNABLE TO FIND STREAM ", Alert.OK);
					break;
				default:
					Alert.show("Error #" + e.data.errorNumber+": " + e.data.errorDescription, "ERROR", Alert.OK);
					break;
				}
			}
			// Handles the result of the bandwidth estimate
			private function bandwidthHandler(e:OvpEvent):void {
				write("Bandwidth measured at " + e.data.bandwidth+ " kbps and latency is " + e.data.latency + " ms.");
				// At this stage you would use the bandwidth result in order to choose
				// the appropriate file for the user.
				playVideo(_filename);
			}
			// Receives all status events dispatched by the active NetConnection
			private function netStatusHandler(e:NetStatusEvent):void {
				write(e.info.code);
				switch (e.info.code) {
					case "NetConnection.Connect.Rejected":
						write("Rejected by server. Reason is "+e.info.description);
						break;
					case "NetConnection.Connect.Success":
						connectedHandler();
						break;
				}
			}

			// Receives all status events dispatched by the active NetStream
			private function streamStatusHandler(e:NetStatusEvent):void {
				trace("****** in FLEXsampleAMDOnDemand.streamStatusHandler() - event.info.code="+e.info.code);
				write(e.info.code);	
				if (e.info.code == "NetStream.Buffer.Full") {
					// _waitForSeek is used to stop the scrubber from updating
					// while the stream transtions after a seek
					_waitForSeek = false;
				}
			}
			// Receives all onPlayStatus events dispatched by the active NetStream
			private function streamPlayStatusHandler(e:OvpEvent):void {				
				write(e.data.code);
			}
			
			// Here comes our id3 info in response to a request to getMp3Id3Info(name)
			private function id3Handler(e:OvpEvent):void {
				for (var i:String in e.data) {
					write("ID3: " + i + " " + e.data[i]);
				}
			}
			
			// Receives all onMetadata events dispatched by the active NetStream
			private function metadataHandler(e:OvpEvent):void {
				for (var propName:String in e.data) {
					write("metadata: "+propName+" = "+e.data[propName]);
				}
				// Adjust the video dimensions on the stage if they do not match the metadata
				if ((Number(e.data["width"]) != _video.width)  || (Number(e.data["height"]) != _video.height)) {
					scaleVideo(Number(e.data["width"]),Number(e.data["height"]));
				}
			}
		
			// Scales the video to fit into the 320x240 window while preserving aspect ratio.
			private function scaleVideo(w:Number,h:Number):void {
				if (w/h >= 4/3) {
					_video.width = 320;
					_video.height = 320*h/w;
				} else {
					_video.width = 240*w/h;
					_video.height = 240;
				}
				_video.x = (_videoHolder.width-_video.width)/2;
				_video.y = (_videoHolder.height-_video.height)/2;
			}
			
			// Receives all cuepoint events dispatched by the active NetStream
			private function cuepointHandler(e:OvpEvent):void {
				for (var propName:String in e.data) {
						if (propName != "parameters") {
							write(propName+" = "+e.data[propName]);
						} else {
							write("parameters =");
							if (e.data.parameters != undefined) {
								for (var paramName:String in e.data.parameters) {
									write(" "+paramName+": "+e.data.parameters[paramName]);
								}
							} else {
								write("undefined");
							}
						}
					}
			}
			
			// Handles the stream length response after a request to requestStreamLength
			private function streamLengthHandler(e:OvpEvent):void {
				write("Stream length is " + e.data.streamLength);
				slider.maximum = e.data.streamLength;
				slider.enabled = true;
				_streamLength = e.data.streamLength;
			}
			
			// Handles async errors dispatched by the net stream class
			private function asyncErrorHandler(e:OvpEvent):void {
				write("Async Error: " + e.data);
			}
			
			// Handles the onFI event which can be added by the Flash Media Live Encoder and 
			// bubbled up by the OVP code base
			private function onFIHandler(e:OvpEvent):void {
				//write("onFI event: timecode (hh:mm:ss:ff) = " + ((e.data.tc) ? e.data.tc : "null") + 
				//	", system date (dd-mm-yy) : " + ((e.data.sd) ? e.data.sd : "null") +
				//	", system time (hh:mm:ss.ms) : " + ((e.data.st) ? e.data.st : "null"));
			}
			
			// Receives information that the end of stream has been reached. This notification
			// uses an analysis of the NetStream status events.
			// It should only be used when playing back progressive content. For streaming content,
			// subscribe to the OvpEvent.COMPLETE event instead.
			private function endHandler(e:OvpEvent):void {
				write("End of stream detected");
				bPlayPause.label = "PLAY";
			}
			// Receives information that stream playback is complete. This notification
			// should not be used when playing back progressive content as the Flash client
			// does not dispatch the NetStream.onPlayStatus event on which this notification is based.
			private function completeHandler(e:OvpEvent):void {
				write("Stream is complete");
				bPlayPause.label = "PLAY";
			}
			// Attaches the video to the stage
			private function addVideoToStage():void {
				_videoHolder= new UIComponent();
				_videoHolder.setActualSize(320,240);
				_video = new Video(320,240);
				_video.x = -160;
				_video.y = -120;
				_videoHolder.addChild(_video);
        		videoWindow.addChild(_videoHolder);
   			}
   			
   			// Plays the stream and requests id3 information if it is a mp3. 
   			private function playVideo(name:String):void {
   				_ns.play(name);
   				bPlayPause.label = "PAUSE";
        		if (name.indexOf("mp3:") != -1) {
        			_ns.getMp3Id3Info(name);
        		}   				
   			}
   			// Updates the time display and slider
   			private function update(e:OvpEvent):void {
   				timeDisplay.text =  _ns.timeAsTimeCode + "|"+ _nc.streamLengthAsTimeCode(_streamLength);
   				if (!_sliderDragging && !_waitForSeek) {
   					slider.value=_ns.time;
   				}
   				if (currentState == "progressive") {
   					progressBar.setProgress(_ns.bytesLoaded,_ns.bytesTotal);
   				}
   			}
   			// Seeks the stream after the slider is dropped
   			private function doSeek():void {
   				write("calling seek to " + slider.value);
   				_ns.seek(slider.value);
   			}
   			// Toggles the dragging state
   			private function toggleDragging(state:Boolean):void {
   				_sliderDragging = state;
   				if (!state) {
   					_waitForSeek = true;
   					doSeek();
   				}
   			}
   			// Handles play and pause
   			private function doPlayPause():void {
   				switch (bPlayPause.label){
   					case "PAUSE":
   					bPlayPause.label = "PLAY";
   					_ns.pause();
   					break;
   					case "PLAY":
   					bPlayPause.label = "PAUSE";
  					_ns.resume();
   					break;
   				}
   			}
   			// Formats the slider dataTip
			private function showVolume(val:String):String {
				return ("Volume: "+Math.round(Number(val)*100)+"%");
			}
			// Converts time to timecode
			private function showScrubTime(val:String):String {
	   			var sec:Number = Number(val);
				var h:Number = Math.floor(sec/3600);
				var m:Number = Math.floor((sec%3600)/60);
				var s:Number = Math.floor((sec%3600)%60);
				return (h == 0 ? "":(h<10 ? "0"+h.toString()+":" : h.toString()+":"))+(m<10 ? "0"+m.toString() : m.toString())+":"+(s<10 ? "0"+s.toString() : s.toString());
			}
			// Changes the stream volume
			private function changeVolume(event:SliderEvent):void {
				if (_ns is OvpNetStream) 
					_ns.volume = event.value;
			}
			
			// Writes trace statements to the output display
			private function write(msg:String):void {
				output.text += msg + "\n";
				output.verticalScrollPosition = output.maxVerticalScrollPosition+1;
			}
		]]>
	</mx:Script>
	<mx:states>
		<mx:State name="progressive">
			<mx:RemoveChild target="{formitem1}"/>
			<mx:RemoveChild target="{formitem2}"/>
			<mx:SetProperty target="{formitem3}" name="label" value="FLV path:"/>
			<mx:SetProperty target="{streamName}" name="width" value="320"/>
			<mx:SetProperty target="{streamName}" name="text">
				<mx:value>http://products.edgeboss.net/download/products/jsherry/testfiles/stream001.flv</mx:value>
			</mx:SetProperty>
			<mx:AddChild relativeTo="{slider}" position="before">
				<mx:ProgressBar width="320" labelPlacement="center"  mode="manual" id="progressBar" minimum="0" indeterminate="false"/>
			</mx:AddChild>
		</mx:State>
	</mx:states>
	
	<mx:HBox x="14" y="10" width="829" height="354">
		<mx:VBox width="450" >
			<mx:Form width="450" height="225" borderStyle="solid">
				<mx:FormHeading label="Ondemand Stream Details"  textAlign="left" width="348"/>
				<mx:FormItem label="Stream type:" width="414">
					<mx:RadioButton label="Streaming (rtmp, rtmpt, rtmpe, rtmpte)" width="249" selected="true" groupName="streamType" id="radiobutton2" click="currentState =''"/>
					<mx:RadioButton label="Progressive (http)" selected="false" groupName="streamType" id="radiobutton1" click="currentState ='progressive'"/>
				</mx:FormItem>
			    <mx:FormItem label="Host name/App name:" id="formitem1">
			        <mx:TextInput id="hostName" width="247" text="cp27886.edgefcs.net/ondemand"/>
			    </mx:FormItem>
			    <mx:FormItem label="Stream name:" id="formitem3">
			        <mx:TextInput id="streamName" width="247" text="14808/nocc_small307K"/>
			    </mx:FormItem>
			    <mx:FormItem label="Authorization parameters:" id="formitem2">
			        <mx:TextInput id="authParams" width="248" text=""/>
			    </mx:FormItem>
			    <mx:FormItem>
			        <mx:Button id="bStart" label="Start" click="startPlayback(hostName.text,streamName.text,authParams.text)"/>
			    </mx:FormItem>
			</mx:Form>
			<mx:Label text="Status:"/>
			<mx:TextArea width="449" height="90" id="output"/>
		    
		</mx:VBox>

		<mx:Canvas width="340" height="346" backgroundAlpha="0.09" backgroundColor="#000000">
			<mx:VBox x="0" y="0" height="100%" width="100%" borderStyle="none" horizontalAlign="center" verticalAlign="middle" id="vbox1">
			  <mx:HBox width="320" height="240" id="videoWindow" borderStyle="none" verticalAlign="middle" horizontalAlign="center" backgroundColor="#000000"/>   	
			  <mx:HSlider allowTrackClick="true" id="slider" enabled="false" dataTipFormatFunction="showScrubTime" thumbPress="toggleDragging(true)" thumbRelease="toggleDragging(false)"       width="320"/>
			  	<mx:ApplicationControlBar width="320" id="applicationcontrolbar1">
			  	     <mx:Button id="bPlayPause" label="PAUSE" click="doPlayPause()" enabled="false"/>
			  	     <mx:Spacer width="100%"  height="28"/>
			  	     <mx:HSlider width="56" height="20" id="volumeSlider"  value="100" dataTipFormatFunction="showVolume" minimum="0" maximum="1" change="changeVolume(event)" allowTrackClick="true"   liveDragging="true"/>
			  	     <mx:Spacer width="10" height="28"/>
			  	     <mx:Text id="timeDisplay"  text="00:00|00:00"  fontWeight="bold"/>
			  	</mx:ApplicationControlBar>
			</mx:VBox>
		</mx:Canvas>
	</mx:HBox>

</mx:Application>
