<?xml version="1.0" encoding="utf-8"?>
<!--
	 //
	 // Copyright (c) 2009, the Open Video Player authors. All rights reserved.
	 //
	 // Redistribution and use in source and binary forms, with or without
	 // modification, are permitted provided that the following conditions are
	 // met:
	 //
	 //    * Redistributions of source code must retain the above copyright
	 //		notice, this list of conditions and the following disclaimer.
	 //    * Redistributions in binary form must reproduce the above
	 //		copyright notice, this list of conditions and the following
	 //		disclaimer in the documentation and/or other materials provided
	 //		with the distribution.
	 //    * Neither the name of the openvideoplayer.org nor the names of its
	 //		contributors may be used to endorse or promote products derived
	 //		from this software without specific prior written permission.
	 //
	 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 //
-->

<mx:Application xmlns:mx="http://www.adobe.com/2006/mxml" implements="org.openvideoplayer.plugins.IOvpPlayer" layout="absolute" applicationComplete="initApp()"
	backgroundGradientColors="[#3a3a3a, #3a3a3a]">

	<mx:Style source="SampleRSS.css"/>

	<mx:Script>
		<![CDATA[
			import com.akamai.net.AkamaiNetStream;
			import com.akamai.net.AkamaiConnection;
			import com.akamai.rss.AkamaiBOSSParser;
			import com.akamai.rss.AkamaiMediaRSS;

			import flash.events.NetStatusEvent;

			import mx.controls.Alert;
			import mx.controls.SWFLoader;
			import mx.events.FlexEvent;
			import mx.events.SliderEvent;
			import mx.managers.SystemManager;

			import org.openvideoplayer.rss.RSSFilterFields;
			import org.openvideoplayer.rss.ItemTO;
			import org.openvideoplayer.advertising.IVPAID;
			import org.openvideoplayer.plugins.*;
			import org.openvideoplayer.net.*;
			import org.openvideoplayer.events.*;
			import org.openvideoplayer.net.OvpCuePointManager;

			[Event(name="cuepoint", type="org.openvideoplayer.plugins.OvpPlayerEvent")]
			[Event(name="error", type="org.openvideoplayer.plugins.OvpPlayerEvent")]
			[Event(name="statechange", type="org.openvideoplayer.plugins.OvpPlayerEvent")]


			//-------------------------------------------------------------------
			//
			// Private vars
			//
			//-------------------------------------------------------------------

			private var _activeNC:AkamaiConnection;
			private var _bossFeed:AkamaiBOSSParser;
			private var _cuePointMgr:OvpCuePointManager;
			private var _currentDeliveryType:String;
			private var _currentKey:String;
			private var _existingConnections:Object;
			private var _filename:String;
			private var _filteredList:Array;
			private var _inAdMode:Boolean;
			private var linearAdMC:MovieClip;
			private var _measuredBandwidth:Number;
			private var _metadata:Object;
			private var _mustSelectStream:Boolean;
			private var _ns:AkamaiNetStream;
			private var _playBtnStatePlaying:Boolean;
			private var _playlist:AkamaiMediaRSS;
			private var _playlistIndex:Number;
			private var _pluginFiles:Array;
			private var _pluginsLoaded:int;
			private var _plugins:Array;
			private var _pluginsStr:String;
			[Bindable]
			private var _rssFeed:String;
			private var _sliderDragging:Boolean;
			private var _state:String;
			private var _streamLength:Number;
			private var _waitForSeek:Boolean;
			private var _video:Video;
			private var _videoHolder:UIComponent;


			//-------------------------------------------------------------------
			//
			// Constants
			//
			//-------------------------------------------------------------------

			private const _SAMPLE_RSS_FEED_:String = "http://rss.streamos.com/streamos/rss/genfeed.php?feedid=1674&groupname=products";
			private const _DEFAULT_VIDEO_WIDTH_:Number = 320;
			private const _DEFAULT_VIDEO_HEIGHT_:Number = 240;


			// ----------------------------------------------------------------
			//
			// IOvpPlayer Implementation
			//
			// ----------------------------------------------------------------

			public function get plugins():Array {
				return _plugins;
			}

			public function get flashvars():Object {
				return parameters;
			}

			public function get currentBitrate():int {
				if (_metadata && _metadata.videodatarate)
					return _metadata.videodatarate;
				return 0;
			}

			public function get duration():Number {
				return _streamLength;
			}

			public function get position():int {
				if (_ns)
					return _ns.time;
				return 0;
			}

			public function get fullScreen():Boolean {
				return false;
			}

			public function get captionsActive():Boolean {
				return false;
			}

			public function get hasVideo():Boolean {
				return true;
			}

			public function get hasAudio():Boolean {
				return true;
			}

			public function get hasCaptions():Boolean {
				return false;
			}

			public function get itemCount():int {
				if (_playlist) {
					return _playlist.itemCount;
				}
				return 0;
			}

			public function get itemsPlayed():int {
				return 0;
			}

			public function get playerWidth():int {
				return playerContainer.width;
			}

			public function get playerHeight():int {
				return playerContainer.height;
			}

			public function get contentWidth():int {
				return _video.width;
			}

			public function get contentHeight():int {
				return _video.height;
			}

			public function get contentTitle():String {
				return "";
			}

			public function get contentURL():String {
				return _filename;
			}

			public function set advertisingMode(value:Boolean):void {
				if (value) {
					_inAdMode = true;

					if (_ns) {
						_ns.pause();
						_ns.volume = volumeControl.value;
					}

					btnStopAd.visible = btnStopAd.includeInLayout = true;
					_video.visible = false;
					linearAdMC.visible = true;
					enablePlayerControls(false);
					dispatchEvent(new OvpPlayerEvent(OvpPlayerEvent.VOLUME_CHANGE, Number(volumeControl.value)));
				} else {
					_inAdMode = false;

					if (_playBtnStatePlaying)
						_ns.resume();

					_video.visible = true;
					linearAdMC.visible = false;
					btnStopAd.visible = btnStopAd.includeInLayout = false;
					enablePlayerControls();
				}
			}

			public function getSpriteById(id:String):Sprite {
				if (id.toLowerCase() == "linearadmc") {
					linearAdMC.visible = true;
					return linearAdMC;
				}
				return null;
			}

			public function addCuePoint(cuePoint:Object):void {
				_cuePointMgr.addCuePoint(cuePoint);
			}


			public function pausePlayer():void {
				_ns.pause();
			}

			public function resumePlayer():void {
				_ns.resume();
			}

			public function startPlayer():void {
				playSelectedItem();
			}

			public function stopPlayer():void {
				_ns.pause();
			}


			//-------------------------------------------------------------------
			//
			// Private
			//
			//-------------------------------------------------------------------

			private function initApp():void {
				_cuePointMgr = new OvpCuePointManager();
				currentState = "progressive";
				_inAdMode = false;
				_playBtnStatePlaying = false;
				_sliderDragging = false;
				_rssFeed = new String(_SAMPLE_RSS_FEED_);
				_streamLength = 0;
				_state = "";
				_waitForSeek = false;

				_video = new Video(_DEFAULT_VIDEO_WIDTH_, _DEFAULT_VIDEO_HEIGHT_);
				_video.x = 0;
				_video.y = 0;

				linearAdMC = new MovieClip();
				linearAdMC.x = 0;
				linearAdMC.y = 0;
				linearAdMC.name = "linearAdMC";

				_videoHolder = new UIComponent();
				_videoHolder.setActualSize(_DEFAULT_VIDEO_WIDTH_, _DEFAULT_VIDEO_HEIGHT_);
				_videoHolder.addChild(_video);
				_videoHolder.addChild(linearAdMC);

				videoContainer.addChild(_videoHolder);

				_existingConnections = new Object();

				_pluginFiles = new Array();
				_plugins = new Array();
				_pluginsLoaded = 0;
				_pluginsStr = parameters.plugins;
				_pluginFiles = _pluginsStr.split(",");

				loadPlugins();
			}


			//-------------------------------------------------------------------
			//
			// Load plug-ins specified in the FlashVars	
			//
			//-------------------------------------------------------------------

			private function loadPlugins():void {
				for (var i:int = 0; i < _pluginFiles.length; i++) {
					var url:String = _pluginFiles[i];

					if (url.search(/.swf$/i) == -1)
						url += ".swf";

					var swfLoader:SWFLoader = new SWFLoader();
					var req:URLRequest = new URLRequest(url);
					var context:LoaderContext = new LoaderContext();

					// We have to load these into the same Application Domain so
					// the plug-ins can call methods here and we
					// can listen for events fired by plug-ins
					context.applicationDomain = ApplicationDomain.currentDomain;
					swfLoader.loaderContext = context;
					swfLoader.trustContent = true;
					swfLoader.addEventListener(Event.COMPLETE, onSwfLoadComplete);
					swfLoader.addEventListener(IOErrorEvent.IO_ERROR, onSwfLoadFailure);
					swfLoader.load(url);
				}
			}

			// Load plugin
			private function loadPlugin(plugIn:IOvpPlugIn):void {
				write("Loading Plugin: " + plugIn.ovpPlugInName);
				plugIn.ovpPlugInTracingOn = true;
				plugIn.initOvpPlugIn(this);
				_pluginsLoaded++;
				if (_pluginsLoaded == _pluginFiles.length)
					handleAllPluginsLoaded();
			}

			// All plugins loaded successfully, enable the load buttons
			private function handleAllPluginsLoaded():void {
				write(_pluginsLoaded + " plug-ins loaded.");
				addEventListener(OvpPlayerEvent.DEBUG_MSG, onDebugMessage, false, 0, true);
				updateState(OvpPlayerEvent.WAITING);
				setUpRSSListeners();
			}

			private function onSwfLoadFailure(e:IOErrorEvent):void {
				Alert.show("Plug-in load failure: " + e.text);
			}

			private function onSwfLoadComplete(e:Event):void {
				var content:DisplayObject = e.target.content;

				// If we don't add it as a child to something, it won't be in the
				// display list and the stage property will be null
				plugin_container.addChild(content);
				_plugins.push(content);

				// If the plug-in was written in Flex, content will be the SystemManager
				// and we need to wait for the Application object to finish loading
				if (content is SystemManager) {
					var sysmgr:SystemManager = (content as SystemManager);
					sysmgr.addEventListener(FlexEvent.APPLICATION_COMPLETE, flexPlugInAppComplete);
				} else {
					if (content is IOvpPlugIn)
						loadPlugin(content as IOvpPlugIn);
				}
			}

			// Called when a plug-in written in Flex has completed loading
			private function flexPlugInAppComplete(e:FlexEvent):void {
				var sysmgr:SystemManager = (e.currentTarget as SystemManager);
				var swfApp:Application = (sysmgr.application as Application);

				if (swfApp is IOvpPlugIn)
					loadPlugin(swfApp as IOvpPlugIn);
			}



			//-------------------------------------------------------------------
			//
			// RSS Methods
			//
			//-------------------------------------------------------------------

			private function setUpRSSListeners():void {
				_playlist = new AkamaiMediaRSS();
				_playlist.addEventListener(OvpEvent.PARSED, rssParsedHandler);
				_playlist.addEventListener(OvpEvent.LOADED, rssLoadHandler);
				_playlist.addEventListener(OvpEvent.ERROR, errorHandler);

				_bossFeed = new AkamaiBOSSParser();
				_bossFeed.addEventListener(OvpEvent.PARSED, bossParsedHandler);
				_bossFeed.addEventListener(OvpEvent.LOADED, bossLoadHandler);
				_bossFeed.addEventListener(OvpEvent.ERROR, errorHandler);

				feedContainer.visible = feedContainer.includeInLayout = true;
			}

			// Handles the load button click for the RSS feed
			private function onLoadRSSFeed(event:MouseEvent):void {
				write("RSS Loading: " + _rssFeed);
				enableInputControls(false);
				_playlist.load(_rssFeed);
			}

			// Handles the notification that the rss feed was successfully loaded.
			private function rssLoadHandler(e:OvpEvent):void {
				write("RSS loaded successfully");
				enableInputControls();
			}

			// Handles the notification that the rss feed was successfully parsed.
			private function rssParsedHandler(e:OvpEvent):void {
				write("RSS parsed successfully");
				filterContainer.visible = filterContainer.includeInLayout = true;
				tileList.dataProvider = _playlist.itemArray;
				tileList.selectedIndex = 0;
				enableInputControls();
				playSelectedItem();
			}

			// Handles the notification that the BOSS feed was successfully loaded.
			private function bossLoadHandler(e:OvpEvent):void {
				write("BOSS loaded successfully");
			}

			// Handles the notification that the BOSS feed was successfully parsed
			private function bossParsedHandler(e:OvpEvent):void {
				write("BOSS parsed successfully");
				var protocol:String = _bossFeed.versionOfMetafile == _bossFeed.METAFILE_VERSION_IV ? _bossFeed.protocol.indexOf("rtmpe") != -1 ? "rtmpe,rtmpte" : "any" : "any";
				startPlayback(_bossFeed.hostName, _bossFeed.streamName, _bossFeed.connectAuthParams, protocol);
			}

			// Commences connection to an ondemand stream
			private function startPlayback(hostname:String, streamname:String, authParams:String = "", protocol:String = "any"):void {
				// The combination of hostname and authParams defines a unique key 
				// which we can use to reference stored connections.
				_currentKey = hostname + authParams;
				_filename = streamname;

				_video.clear();
				_video.attachNetStream(null);

				// Close the current AkamaiConnection 
				if (_activeNC is AkamaiConnection)
					(_activeNC.isProgressive) ? _ns.pause() : _ns.close();

				// If the required connection already exists, then use it
				if (_existingConnections[_currentKey] is AkamaiConnection) {
					_activeNC = _existingConnections[_currentKey];
					startUsingNC();
				} else {
					// Create a new AkamaiConnection
					var _nc:AkamaiConnection = new AkamaiConnection();
					_nc.addEventListener(OvpEvent.ERROR, errorHandler);
					_nc.addEventListener(OvpEvent.BANDWIDTH, bandwidthHandler);
					_nc.addEventListener(OvpEvent.STREAM_LENGTH, streamLengthHandler);
					_nc.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
					_nc.requestedProtocol = protocol;

					if (authParams != "")
						_nc.connectionAuth = authParams;

					_nc.connect(hostname);
				}
			}

			// Start using new AkamaiConnection instance
			private function startUsingNC():void {
				_ns = new AkamaiNetStream(_activeNC);

				// Use fastStart if you are sure the connectivity of your clients is at least
				// twice the bitrate of the video they will be viewing.
				_ns.useFastStartBuffer = true;
				_ns.createProgressivePauseEvents = true;
				_ns.volume = 0;
				_ns.addEventListener(OvpEvent.COMPLETE, endHandler);
				_ns.addEventListener(OvpEvent.PROGRESS, update);
				_ns.addEventListener(NetStatusEvent.NET_STATUS, streamStatusHandler);
				_ns.addEventListener(OvpEvent.NETSTREAM_PLAYSTATUS, streamPlayStatusHandler);
				_ns.addEventListener(OvpEvent.NETSTREAM_METADATA, metadataHandler);
				_ns.addEventListener(OvpEvent.NETSTREAM_CUEPOINT, cuepointHandler);
				_ns.addEventListener(OvpEvent.STREAM_LENGTH, streamLengthHandler);
				_ns.maxBufferLength = 5;

				_video.attachNetStream(_ns);

				// Give the cue point manager the OvpNetStream object so it can start monitoring
				_cuePointMgr.netStream = _ns;

				// Progressive streams don't connect to a streaming server and therefore 
				// can't measure bandwidth
				if (_currentDeliveryType == "video/x-flv") {
					btnPlayPause.label = "PAUSE";
					_ns.play(_filename);
				} else {
					// Assume a streaming file and start the asynchronous process of 
					// requesting the stream length
					_activeNC.requestStreamLength(_filename);
					// Start the asynchronous process of estimating bandwidth. Only do this if 
					// bandwidth has not already been measured.
					if (isNaN(_measuredBandwidth))
						_activeNC.detectBandwidth();
					else {
						btnPlayPause.label = "PAUSE";
						_ns.play(_filename);
					}
				}
			}

			// Perform a seek operation
			private function doSeek():void {
				updateState(OvpPlayerEvent.SEEKING);
				_ns.seek(slider.value);
			}

			private function updateState(state:String):void {
				if (_state != state) {
					_state = state;
					dispatchEvent(new OvpPlayerEvent(OvpPlayerEvent.STATE_CHANGE, _state));
				}
			}

			// Once a good connection is found, this handler will be called
			private function connectedHandler(e:NetStatusEvent):void {
				_existingConnections[_currentKey] = AkamaiConnection(e.currentTarget);
				_activeNC = _existingConnections[_currentKey];
				write("Successfully connected to: " + _activeNC.netConnection.uri);
				write("Port: " + _activeNC.actualPort);
				write("Protocol: " + _activeNC.actualProtocol);
				write("IP address: " + _activeNC.serverIPaddress);
				startUsingNC();
			}


			//-------------------------------------------------------------------
			//
			// Event Handlers
			//
			//-------------------------------------------------------------------

			private function cuepointHandler(e:OvpEvent):void {
				dispatchEvent(new OvpPlayerEvent(OvpPlayerEvent.CUEPOINT, e.data));
			}

			// Handles the OvpEvent.PROGRESS event fired by the OvpNetStream class
			private function update(e:OvpEvent):void {
				timeDisplay.text = _ns.timeAsTimeCode + "|" + _activeNC.streamLengthAsTimeCode(_streamLength);
				if (!_sliderDragging && !_waitForSeek)
					slider.value = _ns.time;
				if (_currentDeliveryType == "video/x-flv")
					progressBar.setProgress(_ns.bytesLoaded, _ns.bytesTotal);
			}

			// Handles all OvpEvent.ERROR events
			private function errorHandler(e:OvpEvent):void {
				write("Error #" + e.data.errorNumber + " " + e.data.errorDescription + " " + e.currentTarget);
				switch (e.data.errorNumber) {
					case OvpError.STREAM_NOT_FOUND:
						Alert.show("Connected to the server at " + _activeNC.serverIPaddress + " but timed-out trying to locate the live stream " + _filename, "UNABLE TO FIND STREAM ", Alert.OK);
						break;
					default:
						Alert.show("Error #" + e.data.errorNumber + ": " + e.data.errorDescription, "ERROR", Alert.OK);
						break;
				}
			}

			// Receives information that the end of stream has been reached
			private function endHandler(e:OvpEvent):void {
				write("End of stream detected.");
				_playlistIndex = _playlistIndex + 1 >= _playlist.itemCount ? 0 : _playlistIndex + 1;
				tileList.selectedIndex = _playlistIndex;
				playSelectedItem();
			}

			// Handles NetStatusEvent.NET_STATUS events fired by the OvpConnection class
			private function netStatusHandler(e:NetStatusEvent):void {
				write(e.info.code);
				switch (e.info.code) {
					case "NetConnection.Connect.Rejected":
						write("Rejected by server. Reason is " + e.info.description);
						break;
					case "NetConnection.Connect.Success":
						connectedHandler(e);
						break;
					// If a connection closes due to a disconnect or idle timeut, 
					// then remove it for the list of available connections
					case "NetConnection.Connect.Closed":
						var key:String = AkamaiConnection(e.target).hostName + "/" + AkamaiConnection(e.target).appNameInstanceName + AkamaiConnection(e.target).connectionAuth;
						delete _existingConnections[key];
						break;
				}
			}

			// Handles the NetStatusEvent.NET_STATUS events fired by the OvpNetStream class
			private function streamStatusHandler(e:NetStatusEvent):void {
				write(e.info.code);
				switch (e.info.code) {
					case "NetStream.Play.StreamNotFound":
						updateState(OvpPlayerEvent.WAITING);
						dispatchEvent(new OvpPlayerEvent(OvpPlayerEvent.ERROR, "stream not found"));
						break;
					case "NetStream.Play.Start":
						updateState(OvpPlayerEvent.BUFFERING);
						if (_inAdMode)
							_ns.pause();
						break;
					case "NetStream.Play.Stop":
						// See if a PDL file has ended (streaming end is handling in 
						// streamPlayStatusHandler
						if (_ns.isProgressive && (duration >= (_ns.time - 1)))
							updateState(OvpPlayerEvent.COMPLETE);
						break;
					case "NetStream.Buffer.Full":
						// _waitForSeek is used to stop the slider from updating while 
						// the stream transtions after a seek
						_waitForSeek = false;
						if (_state != OvpPlayerEvent.PAUSED) {
							updateState(OvpPlayerEvent.PLAYING);
							_ns.volume = volumeControl.value;
							_video.visible = true;
						}
						break;
					case "NetStream.Pause.Notify":
						updateState(OvpPlayerEvent.PAUSED);
						break;
					case "NetStream.Unpause.Notify":
						updateState(OvpPlayerEvent.PLAYING);
						break;
					case "NetStream.Seek.Notify":
						updateState(_state != OvpPlayerEvent.PAUSED ? OvpPlayerEvent.SEEKING : OvpPlayerEvent.PAUSED);
						break;
				}
			}

			// Handles the OvpEvent.NETSTREAM_PLAYSTATUS events fired by the OvpNetStream class
			private function streamPlayStatusHandler(e:OvpEvent):void {
				write(e.data.code);
				switch (e.data.code) {
					case "NetStream.Play.Complete":
						updateState(OvpPlayerEvent.COMPLETE);
						break;
				}
			}

			// Handles the OvpEvent.NETSTREAM_METADATA events fired by the OvpNetStream class
			private function metadataHandler(e:OvpEvent):void {
				_metadata = e.data;
				videoContainer.visible = true;
				// Adjust the video dimensions on the stage if they do not match the metadata
				if ((Number(e.data["width"]) != _video.width) || (Number(e.data["height"]) != _video.height))
					scaleVideo(Number(e.data["width"]), Number(e.data["height"]));
			}

			// Handles slider events (an HSlider object)
			private function toggleDragging(state:Boolean):void {
				_sliderDragging = state;
				if (!state) {
					_waitForSeek = true;
					doSeek();
				}
			}

			// Handles play button events
			private function onClickPlay(event:MouseEvent):void {
				if (_playBtnStatePlaying) {
					_ns.pause();
					btnPlayPause.label = "PLAY";
					updateState(OvpPlayerEvent.PAUSED);
				} else {
					_ns.resume();
					btnPlayPause.label = "PAUSE";
					updateState(OvpPlayerEvent.PLAYING);
				}
				_playBtnStatePlaying = !_playBtnStatePlaying;
			}

			private function streamLengthHandler(e:OvpEvent):void {
				write("Stream length is " + e.data.streamLength);
				slider.maximum = e.data.streamLength;
				_streamLength = e.data.streamLength;
				_ns.volume = .8;
			}

			// Handles the result of the bandwidth estimate
			private function bandwidthHandler(e:OvpEvent):void {
				_measuredBandwidth = e.data.bandwidth;
				write("Bandwidth measured at " + e.data.bandwidth + " kbps and latency is " + e.data.latency + " ms.");
				if (_mustSelectStream) {
					_mustSelectStream = false;
					playSelectedItem();
				} else {
					btnPlayPause.label = "PAUSE";
					_ns.play(_filename);
				}
			}

			private function onChangeVolume(e:SliderEvent):void {
				if (_ns) {
					_ns.volume = e.value;
					dispatchEvent(new OvpPlayerEvent(OvpPlayerEvent.VOLUME_CHANGE, Number(e.value)));
				}
			}

			private function onClickStopAd(e:Event):void {
				// Look for plug-ins that implement IVPAID and tell them to stop playing their ads
				for (var i:int = 0; i < _plugins.length; i++) {
					var plugInSprite:Object = plugInSprite = _plugins[i];
					if ((plugInSprite is IVPAID) || plugInSprite.hasOwnProperty("getVPAID")) {
						var vpaid:IVPAID = plugInSprite.getVPAID() as IVPAID;
						vpaid.stopAd();
						btnStopAd.includeInLayout = btnStopAd.visible = false;
						enablePlayerControls();
					}
				}
			}

			// Plays the selected item in the tileList
			private function playSelectedItem():void {
				var item:ItemTO = ItemTO(tileList.selectedItem);
				var url:String;

				updateState(OvpPlayerEvent.START_NEW_ITEM);
				_playBtnStatePlaying = true;
				btnPlayPause.label = "PAUSE";
				_video.visible = false;
				_playlistIndex = tileList.selectedIndex;

				if (item && item.media.contentArray.length > 1) {
					// Item has group tag, so we need to figure out the correct file to play based
					// on the bandwidth measurement. We assume the content items are specified
					// in an unknown order and therefore we must sort them first.
					if (isNaN(_measuredBandwidth)) {
						// Bandwidth has not yet been measured, but we only know bandwidth after connecting.
						// Therefore, use the first item simply to connect and measure bandwdith and set a flag
						// to revisit this selection routine once the bandwidth is known.
						url = item.media.getContentAt(0).url;
						_mustSelectStream = true;
					} else {
						_mustSelectStream = false;
						var temp:Array = new Array();

						for (var i:uint = 0; i < item.media.contentArray.length; i++) {
							temp.push({index: i, bitrate: Number(item.media.getContentAt(i).bitrate.toString())});
						}

						// Default order will be lowest to highest after sort
						temp.sortOn(sortOnBitrate);
						url = item.media.getContentAt(0).url;
						slider.maximum = timecodeToSeconds(item.media.getContentAt(0).duration);

						for (var j:uint = 0; j < item.media.contentArray.length; j++) {
							if (_measuredBandwidth > 1.5 * item.media.getContentAt(j).bitrate) {
								url = item.media.getContentAt(j).url;
								slider.maximum = timecodeToSeconds(item.media.getContentAt(j).duration);
							}
						}
					}
				} else {
					slider.maximum = timecodeToSeconds(item.media.getContentAt(0).duration);
					url = item.media.getContentAt(0).url;
				}

				_currentDeliveryType = item.enclosure.type;

				// Branch for progressive/streaming playback
				// video/x-flv = progressive
				// application/xml = streaming
				switch (_currentDeliveryType) {
					case "video/x-flv":
						slider.enabled = true;
						currentState = "progressive";
						startPlayback("null", url);
						break;
					case "application/xml":
						currentState = "streaming";
						_bossFeed.load(url);
						break;
					default:
						Alert.show(
							"The media item titled '" + item.media.title + "' did not contain a recognized type attribute.",
							"UNRECOGNIZED MEDIA ITEM TYPE IN RSS FEED",
							Alert.OK);
						break;
				}
			}

			private function onClickFilter(event:MouseEvent):void {
				if (filterText.text == "" || filterText.text == "*") {
					tileList.dataProvider = _playlist.itemArray;
					return;
				}

				var filterFields:RSSFilterFields = new RSSFilterFields();

				switch (rssFields.selectedValue.toString().toLowerCase()) {
					case "title":
						filterFields.title = true;
						break;
					case "description":
						filterFields.description = true;
						break;
					case "all":
						filterFields.setAll(true);
						break;
				}
				var match:int = matchAnyOrAll.selectedValue.toString().toLowerCase() == "any" ? _playlist.FILTER_ANY : _playlist.FILTER_ALL;
				var startFilter:Number = getTimer();
				_filteredList = _playlist.filterItemList(filterText.text, filterFields, match);
				var endFilter:Number = getTimer();
				tileList.dataProvider = _filteredList;
			}


			//-------------------------------------------------------------------
			//
			// Helper Methods
			//
			//-------------------------------------------------------------------

			private function enableInputControls(enable:Boolean = true):void {
				tiRSSFeed.enabled = enable;
				btnLoad.enabled = enable;
			}

			private function enablePlayerControls(enable:Boolean = true):void {
				btnPlayPause.enabled = enable;
				slider.enabled = enable;
			}

			private function showVolume(val:String):String {
				return ("Volume: " + Math.round(Number(val) * 100) + "%");
			}

			// Scales the video to fit into the 320x240 window while preserving aspect ratio.
			private function scaleVideo(w:Number, h:Number):void {
				if (w / h >= 4 / 3) {
					_video.width = _DEFAULT_VIDEO_WIDTH_;
					_video.height = _DEFAULT_VIDEO_WIDTH_ * h / w;
				} else {
					_video.width = _DEFAULT_VIDEO_HEIGHT_ * w / h;
					_video.height = _DEFAULT_VIDEO_HEIGHT_;
				}
				_video.x = (videoContainer.width - _video.width) * 0.5;
				_video.y = (videoContainer.height - _video.height) * 0.5;
			}

			private function showScrubTime(val:String):String {
				var sec:Number = Number(val);
				var h:Number = Math.floor(sec / 3600);
				var m:Number = Math.floor((sec % 3600) / 60);
				var s:Number = Math.floor((sec % 3600) % 60);
				return (h == 0 ? "" : (h < 10 ? "0" + h.toString() + ":" : h.toString() + ":")) + (m < 10 ? "0" + m.toString() : m.toString()) + ":" + (s < 10 ? "0" + s.toString() : s.toString());
			}

			// Sort function for the bitrate array
			private function sortOnBitrate(a:Object, b:Object):Number {
				var aBit:Number = a["bitrate"];
				var bBit:Number = b["bitrate"];

				if (aBit > bBit)
					return 1;
				else if (aBit < bBit)
					return -1;
				else
					return 0;
			}

			// Converts timecode to seconds
			private function timecodeToSeconds(timecode:String):Number {
				return Number(timecode.split(":")[0]) * 3600 + Number(timecode.split(":")[1]) * 60 + Number(timecode.split(":")[2]);
			}

			// Debugging Output
			private function write(... arguments):void {
				text_debug.text += "> SampleRSS - " + arguments + "\n";
			}

			// Debugging Output
			private function onDebugMessage(event:OvpPlayerEvent):void {
				text_debug.text += (event.data as String) + "\n";
			}
		]]>
	</mx:Script>


	<!--
		 /////////////////////////////////////////////////////////////////////
		 //
		 // States
		 //
		 /////////////////////////////////////////////////////////////////////
	-->

	<mx:states>
		<mx:State name="progressive">
			<mx:SetProperty value="true" name="visible" target="{progressBar}"/>
			<mx:SetProperty value="true" name="includeInLayout" target="{progressBar}"/>
		</mx:State>
		<mx:State name="streaming">
			<mx:SetProperty value="false" name="visible" target="{progressBar}"/>
			<mx:SetProperty value="false" name="includeInLayout" target="{progressBar}"/>
		</mx:State>
	</mx:states>


	<!--
		 /////////////////////////////////////////////////////////////////////
		 //
		 // View
		 //
		 /////////////////////////////////////////////////////////////////////
	-->

	<mx:VBox id="mainContainer" paddingBottom="20" paddingLeft="10" paddingRight="10" paddingTop="20">

		<!-- Title -->
		<mx:Label styleName="title" text="OVP RSS Sample implementing VAST and VPAID Standards"/>

		<mx:Label text="Enter the path to the StreamOS MediaRSS playlist and then press the LOAD button" />

		<mx:HBox id="feedContainer" horizontalScrollPolicy="off" includeInLayout="false" visible="false" width="{playerContainer.width}" verticalAlign="middle">
			<mx:Label text="RSS Feed: "/>
			<mx:TextInput id="tiRSSFeed" text="{_rssFeed}" width="100%" editable="true"/>
			<mx:Button id="btnLoad" label="LOAD" click="onLoadRSSFeed(event)" buttonMode="true" useHandCursor="true"/>
		</mx:HBox>

		<mx:Spacer height="10"/>


		<!--
			 /////////////////////////////////////////////////////////////////////
			 //
			 // Left Column - Player and Controls
			 //
			 /////////////////////////////////////////////////////////////////////
		-->

		<mx:HBox>
			<mx:VBox horizontalAlign="center">

				<mx:VBox id="playerContainer" backgroundColor="#333333" horizontalAlign="center" paddingBottom="10" paddingLeft="10" paddingRight="10" paddingTop="10" verticalGap="5">

					<mx:Box id="videoContainer" horizontalScrollPolicy="off" verticalScrollPolicy="off" height="{_DEFAULT_VIDEO_HEIGHT_}" width="{_DEFAULT_VIDEO_WIDTH_}" backgroundColor="#242424"/>

					<!-- Player Controls -->
					<mx:HSlider id="slider" allowTrackClick="true" dataTipFormatFunction="showScrubTime" enabled="false" width="100%" thumbPress="toggleDragging(true)"
						thumbRelease="toggleDragging(false)"/>

					<mx:ProgressBar id="progressBar" indeterminate="false" label="Loading Video..." labelPlacement="center" minimum="0" mode="manual" width="100%"/>

					<mx:ApplicationControlBar id="playerControls" width="100%">
						<mx:Button id="btnPlayPause" enabled="false" label="PAUSE" click="onClickPlay(event)" buttonMode="true" useHandCursor="true"/>
						<mx:Button id="btnStopAd" includeInLayout="false" visible="false" label="Stop Ad" click="onClickStopAd(event)" buttonMode="true" useHandCursor="true"/>
						<mx:Spacer width="100%"/>
						<mx:HSlider id="volumeControl" allowTrackClick="true" dataTipFormatFunction="showVolume" enabled="true" maximum="1" minimum="0" value="1" width="100"
							thumbRelease="onChangeVolume(event)"/>
						<mx:Text id="timeDisplay" text="00:00|00:00"/>
					</mx:ApplicationControlBar>

				</mx:VBox>

				<mx:TextArea id="text_debug" height="200" width="100%" valueCommit="text_debug.verticalScrollPosition = text_debug.maxVerticalScrollPosition" color="0x000000"/>
			</mx:VBox>


			<!--
				 /////////////////////////////////////////////////////////////////////
				 //
				 // Right Column
				 //
				 /////////////////////////////////////////////////////////////////////
			-->

			<mx:VBox height="100%" width="100%">
				<mx:VBox id="filterContainer" includeInLayout="false" visible="false">
					<mx:HBox>
						<mx:VBox>
							<mx:Label text="Filter Text"/>
							<mx:TextInput id="filterText"/>
						</mx:VBox>

						<mx:VBox>
							<mx:Label/>
							<mx:Button id="bFilter" label="FILTER" click="onClickFilter(event)"/>
						</mx:VBox>

						<mx:VBox paddingLeft="12">
							<mx:Label text="RSS Fields"/>
							<mx:HBox>
								<mx:RadioButtonGroup id="rssFields"/>
								<mx:RadioButton label="Title" groupName="rssFields"/>
								<mx:RadioButton label="Description" groupName="rssFields"/>
								<mx:RadioButton label="All" selected="true" groupName="rssFields"/>
							</mx:HBox>
						</mx:VBox>

						<mx:VBox paddingLeft="12">
							<mx:Label text="Match"/>
							<mx:HBox>
								<mx:RadioButtonGroup id="matchAnyOrAll"/>
								<mx:RadioButton label="Any" selected="true" groupName="matchAnyOrAll"/>
								<mx:RadioButton label="All" groupName="matchAnyOrAll"/>
							</mx:HBox>
						</mx:VBox>
					</mx:HBox>
					<mx:HRule width="100%"/>
				</mx:VBox>

				<mx:VBox verticalScrollPolicy="auto" height="100%" width="100%">
					<mx:TileList id="tileList" verticalScrollPolicy="auto" height="100%" width="100%" change="playSelectedItem()">
						<mx:itemRenderer>
							<mx:Component>
								<mx:VBox height="150" width="150" backgroundColor="0x3a3a3a" horizontalAlign="center">
									<mx:Text id="albumName" text="{data.title}" width="120"/>
									<mx:Image id="albumImage" source="{data.media.thumbnail.url}" height="90" width="120"/>
								</mx:VBox>
							</mx:Component>
						</mx:itemRenderer>
					</mx:TileList>
				</mx:VBox>

			</mx:VBox>
		</mx:HBox>
	</mx:VBox>

	<!-- Plug In Container -->
	<mx:UIComponent id="plugin_container" includeInLayout="false" visible="false"/>

</mx:Application>
