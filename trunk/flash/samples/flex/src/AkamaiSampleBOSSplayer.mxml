<?xml version="1.0" encoding="utf-8"?>
<!--
//
// Copyright (c) 2009, the Open Video Player authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without 
// modification, are permitted provided that the following conditions are 
// met:
//
//    * Redistributions of source code must retain the above copyright 
//		notice, this list of conditions and the following disclaimer.
//    * Redistributions in binary form must reproduce the above 
//		copyright notice, this list of conditions and the following 
//		disclaimer in the documentation and/or other materials provided 
//		with the distribution.
//    * Neither the name of the openvideoplayer.org nor the names of its 
//		contributors may be used to endorse or promote products derived 
//		from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
-->
<mx:Application xmlns:mx="http://www.adobe.com/2006/mxml" layout="absolute"  clipContent="false"  
	applicationComplete="init()" width="850" height="510" >
	<mx:Script>
		<![CDATA[	
			import mx.core.UIComponent;
			import mx.events.SliderEvent;
			import mx.controls.Alert;
			import flash.geom.*; 
			import flash.events.FullScreenEvent;
			import flash.display.Stage;
			import flash.display.StageDisplayState;
			
			import org.openvideoplayer.events.*;
			import org.openvideoplayer.net.*;
			import org.openvideoplayer.rss.*;
			
			import com.akamai.net.*;
			import com.akamai.rss.*;
					
			// Define private variables
			private var _nc:AkamaiConnection;
			private var _ns:AkamaiNetStream;
			private var _bossMetafile:AkamaiBOSSParser;
			private var _sliderDragging:Boolean;
			private var _waitForSeek:Boolean;
			private var _video:Video;
			private var _videoHolder:UIComponent;
			private var _bandwidthMeasured:Boolean;
			private var _hasEnded:Boolean;
			private var _videoSettings:Object;
			private var _isLive:Boolean;
			private var _streamLength:Number;
			
			
			private const SAMPLES:Array = [
								{label:"Metafile version I",data:"http://products.edgeboss.net/flash/products/mediaframework/fms/0223_quikpro_highlights_700.flv?xmlvers=1"},
								{label:"Metafile version II",data:"http://products.edgeboss.net/flash/products/mediaframework/fms/akamai_10ya_nab_700k.flv?xmlvers=2"},
								{label:"Progressive sample 1",data:"http://products.edgeboss.net/download/products/mediaframework/fms/0223_quikpro_lgwaveoftheday_web_700.flv"},
								{label:"Progressive sample 2",data:"http://products.edgeboss.net/download/products/mediaframework/fms/0406_bells_35thyearparty_big.flv"}
								];
			
			// Define functions
			private function init():void {
				_isLive = false;
				
				stage.addEventListener(FullScreenEvent.FULL_SCREEN, handleReturnFromFullScreen);
				//
				_bossMetafile = new AkamaiBOSSParser();
				_bossMetafile.addEventListener(OvpEvent.PARSED,bossParsedHandler);
				_bossMetafile.addEventListener(OvpEvent.LOADED,bossLoadHandler);
				_bossMetafile.addEventListener(OvpEvent.ERROR,errorHandler);
				//
				_nc = new AkamaiConnection();
				// This example shows all the possible events that you may subscribe to.
				// In a real project, you would only choose a subset of these. 
				_nc.addEventListener(OvpEvent.ERROR,errorHandler);
				_nc.addEventListener(OvpEvent.BANDWIDTH,bandwidthHandler);
				_nc.addEventListener(OvpEvent.STREAM_LENGTH,streamLengthHandler); 
				_nc.addEventListener(NetStatusEvent.NET_STATUS,netStatusHandler);
				
				_bandwidthMeasured = false;
				addVideoToStage();
				//
				bossLink.text = cbLinks.selectedItem.data;
					
			}	
			// Handles the notification that the BOSS feed was successfully loaded.
			private function bossLoadHandler(e:OvpEvent):void {
				write("BOSS loaded successfully");
			}
			// Handles the notification that the BOSS feed was successfully parsed
			private function bossParsedHandler(e:OvpEvent):void {
				write("BOSS parsed successfully:");
				write("========== Metafile data ==============");
				switch (_bossMetafile.versionOfMetafile) {
					case _bossMetafile.METAFILE_VERSION_I:
						write("  Server name: " + _bossMetafile.serverName);
						write("  Fallback server name: " + _bossMetafile.fallbackServerName);
						write("  App name: " + _bossMetafile.appName);
						write("  Stream name: " + _bossMetafile.streamName);
						write("  Is live: " + _bossMetafile.isLive);
						write("  Buffer time: " + _bossMetafile.bufferTime);
						write("  Connect Auth Params: " + _bossMetafile.connectAuthParams);
						write("  Play Auth Params: " + _bossMetafile.playAuthParams);
						_nc.requestedProtocol = "any";
					break;
					case _bossMetafile.METAFILE_VERSION_II:
						write("  Server name: " + _bossMetafile.serverName);
						write("  App name: " + _bossMetafile.appName);
						write("  Stream name: " + _bossMetafile.streamName);
						write("  Is live: " + _bossMetafile.isLive);
						write("  Buffer time: " + _bossMetafile.bufferTime);
						write("  Connect Auth Params: " + _bossMetafile.connectAuthParams);
						write("  Play Auth Params: " + _bossMetafile.playAuthParams);
						_nc.requestedProtocol = "any";
					break;
					case _bossMetafile.METAFILE_VERSION_IV:
						write("  Server name: " + _bossMetafile.serverName);
						write("  App name: " + _bossMetafile.appName);
						write("  Stream name: " + _bossMetafile.streamName);
						write("  Protocol: " + _bossMetafile.protocol);
						write("  Is live: " + _bossMetafile.isLive);
						write("  Title: " + _bossMetafile.title);
						write("  Source: " + _bossMetafile.source);
						write("  Author: " + _bossMetafile.author);
						write("  Clip begin: " + _bossMetafile.clipBegin);
						write("  Clip end: " + _bossMetafile.clipEnd);
						write("  Duration: " + _bossMetafile.duration);
						write("  Connect Auth Params: " + _bossMetafile.connectAuthParams);
						write("  Play Auth Params: " + _bossMetafile.playAuthParams);
						write("  Secondary Encoder Source: " + _bossMetafile.secondaryEncoderSrc);
						write("  Keywords: " + _bossMetafile.keywords);
						_nc.requestedProtocol = _bossMetafile.protocol.indexOf("rtmpe") != -1 ? "rtmpe,rtmpte":"any";
					break;
				}
				write("======= End of Metafile data ===========");
				// Establish the connection
				trace("requested protocl set to " + _nc.requestedProtocol);
				_nc.connectionAuth = _bossMetafile.connectAuthParams;
				currentState = _bossMetafile.isLive ? "live":"";
				_isLive = _bossMetafile.isLive;
				_nc.connect(_bossMetafile.hostName); 
			}
			// Commences connection to a new link
			private function startPlayback():void {
				output.text = "";
				bPlayPause.enabled = false;
				bFullscreen.enabled = false;
				_hasEnded = false;
				// Clean up from previous session, if it exists
				if (_nc.netConnection is NetConnection) {
					_ns.useFastStartBuffer = false;
					_nc.close();
				}
				// Decide if the link will return a BOSS xml metafile, or if it is
				// a direct reference to a progressive FLV file. 
				if (bossLink.text.split("/").length > 3 && bossLink.text.split("/")[3].toUpperCase() == "DOWNLOAD") {
					_nc.connect(null); 
				} else {
					_bossMetafile.load(bossLink.text)
				}
				
			}
			// Once a good connection is found, this handler will be called
			private function connectedHandler():void {
				_ns = new AkamaiNetStream(_nc.netConnection);

				_ns.addEventListener(OvpEvent.COMPLETE,completeHandler); 
				_ns.addEventListener(OvpEvent.PROGRESS,update); 
				_ns.addEventListener(NetStatusEvent.NET_STATUS,streamStatusHandler);
				_ns.addEventListener(OvpEvent.NETSTREAM_PLAYSTATUS,streamPlayStatusHandler);
				_ns.addEventListener(OvpEvent.NETSTREAM_METADATA,metadataHandler);
				_ns.addEventListener(OvpEvent.NETSTREAM_CUEPOINT,cuepointHandler);
				_ns.addEventListener(OvpEvent.STREAM_LENGTH,streamLengthHandler); 				
				
				_ns.maxBufferLength = 2;
				_ns.liveStreamAuthParams = _bossMetafile.playAuthParams;

				_ns.useFastStartBuffer = !_isLive;
				_video.visible = _isLive;
				_video.attachNetStream(_ns);
				// Branchbased on the playback mode
				if (_ns.isProgressive) {
					currentState = "progressive";
					write("Progressive connection established");
					playVideo(bossLink.text);
				} else {
					currentState = "";
					write("Successfully connected to: " + _nc.netConnection.uri);
					write("Port: " + _nc.actualPort);
					write("Protocol: " + _nc.actualProtocol);
					write("Server IP address: " + _nc.serverIPaddress);
					// If an ondemand stream, start the asynchronous process of requesting the stream length 
					if (!_isLive) {
						_nc.requestStreamLength(_bossMetafile.streamName);
					}
					// start the asynchronous process of estimating bandwidth if it hasn;t already been esimated
					if (_bandwidthMeasured) {
						playVideo(_bossMetafile.streamName);
					} else {
						write("Measuring bandwidth ... ");
						_nc.detectBandwidth();
					}
				}
			}
			// Handles all error events
			private function errorHandler(e:OvpEvent):void {
				switch(e.data.errorNumber) {
				case OvpError.STREAM_NOT_FOUND:
					Alert.show("Connected to the server at " + _nc.serverIPaddress + " but timed-out trying to locate the live stream " + _bossMetafile.streamName, "UNABLE TO FIND STREAM ", Alert.OK);
					break;
				default:
					Alert.show("Error #" + e.data.errorNumber+": " + e.data.errorDescription, "ERROR", Alert.OK);
					break;
				}
			}
			// Handles the result of the bandwidth estimate
			private function bandwidthHandler(e:OvpEvent):void {
				_bandwidthMeasured  = true;
				write("Bandwidth measured at " + e.data.bandwidth+ " kbps and latency is " + e.data.latency + " ms.");
				// At this stage you would use the bandwidth result in order to choose
				// the appropriate file for the user.
				playVideo(_bossMetafile.streamName);
			}
			// Receives all status events dispatched by the active NetConnection
			private function netStatusHandler(e:NetStatusEvent):void {
				write(e.info.code);
				switch (e.info.code) {
					case "NetConnection.Connect.Rejected":
						write("Rejected by server. Reason is "+e.info.description);
						break;
					case "NetConnection.Connect.Success":
						connectedHandler();
						break;
				}
			}
			// Receives all status events dispatched by the active NetStream
			private function streamStatusHandler(e:NetStatusEvent):void {
				write(e.info.code);	
				if (e.info.code == "NetStream.Buffer.Full") {
					// _waitForSeek is used to stop the scrubber from updating
					// while the stream transtions after a seek
					_waitForSeek = false;
				}
			}
			// Receives all onPlayStatus events dispatched by the active NetStream
			private function streamPlayStatusHandler(e:OvpEvent):void {
				write(e.data.code);
			}
			// Handles a successfull subscription to a live stream
			private function subscribedHandler(e:OvpEvent):void {
				write("Successfully subscribed to the live stream");
				bPlayPause.enabled = true;
				bFullscreen.enabled = true;
			}
			// Handles unsubscription form a live stream
			private function unsubscribedHandler(e:OvpEvent):void {
				write("Unubscribed from the live stream");
				bPlayPause.enabled = false;
				bFullscreen.enabled = false;
			}
			// Notifies the user that the class is making another attempt to subscribe to a live stream
			private function subscribeAttemptHandler(e:OvpEvent):void {
				write("Attempting to subscribe to the live stream ...");
			}
			// Receives all onMetadata events dispatched by the active NetStream
			private function metadataHandler(e:OvpEvent):void {
				write("========== Metadata found in stream  ===========");
				for (var propName:String in e.data) {
					write("  "+propName+" = "+e.data[propName]);
				}
				write("========== End of Stream Metadata  ===========");
				// Adjust the video dimensions on the stage if they do not match the metadata
				if ((Number(e.data["width"]) != _video.width)  || (Number(e.data["height"]) != _video.height)) {
					scaleVideo(Number(e.data["width"]),Number(e.data["height"]));
				}
			}
			// Scales the video to fit into the 320x240 window while preserving aspect ratio.
			private function scaleVideo(w:Number,h:Number):void {
				if (w/h >= 4/3) {
					_video.width = 320;
					_video.height = 320*h/w;
				} else {
					_video.width = 240*w/h;
					_video.height = 240;
				}
				_video.x = (_videoHolder.width-_video.width)/2;
				_video.y = (_videoHolder.height-_video.height)/2;
				_video.visible = true;
			}
			// Receives all cuepoint events dispatched by the active NetStream
			private function cuepointHandler(e:OvpEvent):void {
				for (var propName:String in e.data) {
						if (propName != "parameters") {
							write(propName+" = "+e.data[propName]);
						} else {
							write("parameters =");
							if (e.data.parameters != undefined) {
								for (var paramName:String in e.data.parameters) {
									write(" "+paramName+": "+e.data.parameters[paramName]);
								}
							} else {
								write("undefined");
							}
						}
					}
			}
						
			// Handles the stream length response after a request to requestStreamLength
			private function streamLengthHandler(e:OvpEvent):void {
				write("Stream length is " + e.data.streamLength);
				slider.maximum = e.data.streamLength;
				slider.enabled = true;
				bPlayPause.enabled = true;
				bFullscreen.enabled = true;
				_streamLength = e.data.streamLength;
			}
			// Receives information that stream playback is complete. This notification
			// should not be used when playing back progressive content as the Flash client
			// does not dispatch the NetStream.onPlayStatus event on which this notification is based.
			private function completeHandler(e:OvpEvent):void {
				write("Stream is complete");
				_hasEnded = true;
				bPlayPause.label = "PLAY";
			}
			// Attaches the video to the stage
			private function addVideoToStage():void {
				_videoHolder= new UIComponent();
				_video = new Video(320,240);
				_video.smoothing = true;
				_video.visible = false;
				_video.x = (_videoHolder.width-_video.width)/2;
				_video.y = (_videoHolder.height-_video.height)/2;
				_videoHolder.addChild(_video);
        		videoWindow.addChild(_videoHolder);
   			}
   			// Plays the stream 
   			private function playVideo(name:String):void {
   				_ns.play(name);
   				bPlayPause.label = "PAUSE";  				
   			}
   			// Updates the time display and slider
   			private function update(e:OvpEvent):void {
   				timeDisplay.text = _isLive ? _ns.timeAsTimeCode : _ns.timeAsTimeCode + "|"+ _nc.streamLengthAsTimeCode(_streamLength);
   				if (!_isLive) {
   					if (!_sliderDragging && !_waitForSeek) {
   						slider.value = _ns.time;
   					}
   				}
   				if (_nc.isProgressive) {
   					progressBar.setProgress(_ns.bytesLoaded, _ns.bytesTotal);
   				}
   			}
   			// Seeks the stream after the slider is dropped
   			private function doSeek():void {
   				write("calling seek to " + slider.value);
   				if (_hasEnded) {
   					_hasEnded = false;
   					_ns.play(_nc.isProgressive ? bossLink.text: _bossMetafile.streamName);
   					bPlayPause.label = "PAUSE";
   				} 
   				_ns.seek(slider.value);
   			}
   			// Toggles the dragging state
   			private function toggleDragging(state:Boolean):void {
   				_sliderDragging = state;
   				if (!state) {
   					_waitForSeek = true;
   					doSeek();
   				}
   			}
   			// Handles play and pause
   			private function doPlayPause():void {
   				switch (bPlayPause.label){
   					case "PAUSE":
   						bPlayPause.label = "PLAY";
   						_ns.pause();
   					break;
   					case "PLAY":
   						bPlayPause.label = "PAUSE";
   						if (_hasEnded) {
   							_hasEnded = false;
   							_ns.play(_nc.isProgressive ? bossLink.text: _bossMetafile.streamName);
   						} else {
   							_ns.resume();
   						}
   					break;
   				}
   			}
   			// Formats the slider dataTip
			private function showVolume(val:String):String {
				return ("Volume: "+Math.round(Number(val)*100)+"%");
			}
			// Converts time to timecode
			private function showScrubTime(val:String):String {
	   			var sec:Number = Number(val);
				var h:Number = Math.floor(sec/3600);
				var m:Number = Math.floor((sec%3600)/60);
				var s:Number = Math.floor((sec%3600)%60);
				return (h == 0 ? "":(h<10 ? "0"+h.toString()+":" : h.toString()+":"))+(m<10 ? "0"+m.toString() : m.toString())+":"+(s<10 ? "0"+s.toString() : s.toString());
			}
			// Changes the stream volume
			private function changeVolume(event:SliderEvent):void {
				if (_ns is AkamaiNetStream) 
					_ns.volume = event.value;
			}
			// Writes trace statements to the output display
			private function write(msg:String):void {
				output.text += msg + "\n";
				output.verticalScrollPosition = output.maxVerticalScrollPosition+1;
			}
			// Switches to full screen mode
			private function switchToFullScreen():void {
				    // when going out of full screen mode 
				    // we use these values
				    _videoSettings = new Object();
				    _videoSettings.savedWidth = _videoHolder.width;
				    _videoSettings.savedHeight = _videoHolder.height;
				    _videoSettings.x = _videoHolder.x;
				    _videoSettings.y = _videoHolder.y;
				    stage["fullScreenSourceRect"] = new Rectangle(0,0, _video.videoWidth ,_video.videoHeight);	 
				    stage["displayState"] = StageDisplayState.FULL_SCREEN;
				    videoWindow.removeChild(_videoHolder);
				    addChild(_videoHolder);
				   	_video.x = _videoHolder.x = 0;
				   	_video.y = _videoHolder.y = 0;
				    _video.width =  _videoHolder.width = _video.videoWidth;
				    _video.height =  _videoHolder.height = _video.videoHeight;
				    _video.width =  _videoHolder.width = _video.videoWidth;
				    _video.height =  _videoHolder.height = _video.videoHeight;
				    _video.smoothing = false;
		    
				   
			}
			// Handles the return from fullscreen
			private function handleReturnFromFullScreen(e:FullScreenEvent):void {
				if (!e.fullScreen) {
					removeChild(_videoHolder);
					videoWindow.addChild(_videoHolder);
				    _video.smoothing = true;
				    _videoHolder.width = _videoSettings.savedWidth;
				    _videoHolder.height = _videoSettings.savedHeight;
				    _videoHolder.x = _videoSettings.x
				   	_videoHolder.y = _videoSettings.y
				    scaleVideo(_video.videoWidth,_video.videoHeight);
				}
			}
		]]>
	</mx:Script>
	<mx:states>
		<mx:State name="live">
			<mx:RemoveChild target="{slider}"/>
		</mx:State>
		<mx:State name="progressive">
			<mx:AddChild relativeTo="{slider}" position="before">
				<mx:ProgressBar id="progressBar" width="320" label="" mode="manual" minimum="0" maximum="1" height="11"/>
			</mx:AddChild>
		</mx:State>
	</mx:states>
	<mx:VBox width="830" height="490" id="vbox3" left="10" top="10">
	    <mx:Canvas width="100%" height="85" id="canvas1">
	    	 <mx:ComboBox width="169" id="cbLinks" selectedIndex="0" dataProvider="{SAMPLES}" change="bossLink.text = cbLinks.selectedItem.data" x="0" y="40"></mx:ComboBox>
			 <mx:TextInput id="bossLink" width="547" x="177" y="40"/>
			 <mx:Button id="bStart" label="Start" click="startPlayback()" x="741" y="40"/>
			 <mx:Label x="0" y="10" text="Stream OS Flash Video Reference Player" fontWeight="bold" fontSize="16" width="387"/>
			 <mx:Label x="177" y="64" text="[Enter your Stream OS BOSS link in the box above, or select a sample from the pull-down options.]" fontSize="9" id="label1"/>
	    </mx:Canvas>
	    <mx:HBox id="hbox1">
		<mx:VBox width="450"  height="339" id="vbox2">
			<mx:Label text="Status:"/>
			<mx:TextArea width="420" height="305" id="output"/>
		</mx:VBox>
		<mx:Canvas width="340" height="346" backgroundAlpha="0.09" backgroundColor="#000000">
			<mx:VBox x="0" y="0" height="100%" width="100%" borderStyle="none" horizontalAlign="center" verticalAlign="middle" id="vbox1">
			  <mx:HBox width="320" height="240" id="videoWindow" borderStyle="none" verticalAlign="middle" horizontalAlign="center" backgroundColor="#000000"/>   	
			  <mx:HSlider allowTrackClick="true" id="slider" enabled="false" dataTipFormatFunction="showScrubTime" thumbPress="toggleDragging(true)" thumbRelease="toggleDragging(false)"       width="320"/>
			  	<mx:ApplicationControlBar width="320" id="applicationcontrolbar1">
			  	     <mx:Button id="bPlayPause" label="PAUSE" click="doPlayPause()" enabled="false"/>
			  	     <mx:Button id="bFullscreen" label="FULLSCREEN" click="switchToFullScreen()"  enabled="false"/>
			  	     <mx:HSlider width="46" height="20" id="volumeSlider"  value="100" dataTipFormatFunction="showVolume" minimum="0" maximum="1" change="changeVolume(event)" allowTrackClick="true"   liveDragging="true"/>
			  	     <mx:Text id="timeDisplay"  text="00:00|00:00"  fontWeight="bold"/>
			  	</mx:ApplicationControlBar>
			</mx:VBox>
		</mx:Canvas>
		</mx:HBox>
	</mx:VBox>

</mx:Application>
