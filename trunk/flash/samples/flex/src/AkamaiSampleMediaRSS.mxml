<?xml version="1.0" encoding="utf-8"?>
<!--
//
// Copyright (c) 2009, the Open Video Player authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without 
// modification, are permitted provided that the following conditions are 
// met:
//
//    * Redistributions of source code must retain the above copyright 
//		notice, this list of conditions and the following disclaimer.
//    * Redistributions in binary form must reproduce the above 
//		copyright notice, this list of conditions and the following 
//		disclaimer in the documentation and/or other materials provided 
//		with the distribution.
//    * Neither the name of the openvideoplayer.org nor the names of its 
//		contributors may be used to endorse or promote products derived 
//		from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
-->
<mx:Application xmlns:mx="http://www.adobe.com/2006/mxml" layout="absolute" creationComplete="init()"
	viewSourceURL="srcview/index.html" backgroundGradientColors="[#3a3a3a, #3a3a3a]">
<!--
This application is a reference FLEX application demonstrating integration between the AkamaiConnection, AkamaiMediaRSS and
AkamaiBOSSParser classes, in conjunction the event and RSS subclasses which together comprise the Flash Media 
Player framework.

The application loads a RSS feed from StreamOS, parses it, displays the items and begins autoplaying the first item. The player
handles both streaming and progressive links and has a connection optimization routine so that existing AkamaiConnection
instances are re-used as much as possible. The class supports the group tag in the MediaRSS for streaming links, allowing 
measured bandwidth to dictate which of the grouped content items to use. 

The UI and functional elements of this player have been wrapped into this single mxml file for ease of distribution. In a real-world application
Akamai recommends breaking at the various UI and functional items into reusable sub-classes and deploying a traditional MVC architecture. 
-->
<mx:Style>
	global {
		fontFamily: "Verdana";
		fontSize: 10px;
		color: #ffffff;
		fontWeight: normal;
	}
	
	TextInput {
		color: #000000;
	}
	
	RadioButton {
		color: #dddddd;
		textRollOverColor: #ffffff;
	}
	
	ToolTip {
		backgroundColor: #7a7a7a;
	}
	
	.title {
		fontSize:14px;
		fontWeight:bold;
	}
	
	.strong {
		fontWeight:bold;
	}

</mx:Style>
	<mx:Script>
		<![CDATA[
			import mx.core.UIComponent;
			import mx.events.SliderEvent;
			import mx.controls.Alert;
			
			import org.openvideoplayer.events.*;
			import org.openvideoplayer.net.*;
			import org.openvideoplayer.rss.*;
			
			import com.akamai.net.*;
			import com.akamai.rss.*;
			
			// Define private variables
			private var _ns:AkamaiNetStream;
			private var _filename:String;
			private var _sliderDragging:Boolean;
			private var _waitForSeek:Boolean;
			private var _video:Video;
			private var _videoHolder:UIComponent;
			private var _playlist:AkamaiMediaRSS;
			private var _bossFeed:AkamaiBOSSParser;
			private var _existingConnections:Object;
			private var _currentKey:String;
			private var _activeNC:AkamaiConnection;
			private var _measuredBandwidth:Number;
			private var _playlistIndex:Number;
			private var _mustSelectStream:Boolean;
			private var _currentDeliveryType:String;
			private var _filteredList:Array;
			private var _streamLength:Number;
			private var _isLive:Boolean;
		
			private const SAMPLE_URL:String = "http://rss.streamos.com/streamos/rss/genfeed.php?feedid=1674&groupname=products";
			
			// Initialize primary feed holders and UI elements
			private function init():void {
				_isLive = false;
				
				_playlist = new AkamaiMediaRSS();
				_playlist.addEventListener(OvpEvent.PARSED,rssParsedHandler);
				_playlist.addEventListener(OvpEvent.LOADED,rssLoadHandler);
				_playlist.addEventListener(OvpEvent.ERROR,errorHandler);
				//
				_bossFeed = new AkamaiBOSSParser();
				_bossFeed.addEventListener(OvpEvent.PARSED,bossParsedHandler);
				_bossFeed.addEventListener(OvpEvent.LOADED,bossLoadHandler);
				_bossFeed.addEventListener(OvpEvent.ERROR,errorHandler);
				//
				_existingConnections = new Object();
				//
				_videoHolder= new UIComponent();
				_videoHolder.setActualSize(320,240);
				_video = new Video(320,240);
				_video.x = -160;
				_video.y = -120;
				_videoHolder.addChild(_video);
        		videoWindow.addChild(_videoHolder);
        		
        		playlistPath.text = SAMPLE_URL;
			}
			// Handles the notification that the rss feed was successfully loaded.
			private function rssLoadHandler(e:OvpEvent):void {
				bLoad.enabled = true;
				write("RSS loaded successfully");
			}
			// Handles the notification that the rss feed was successfully parsed.
			private function rssParsedHandler(e:OvpEvent):void {
				write("RSS parsed successfully");
				filterContainer.visible = filterContainer.includeInLayout = true;
				tileList.dataProvider = _playlist.itemArray;
				tileList.selectedIndex = 0;
				playSelectedItem();
			}
			// Handles the notification that the BOSS feed was successfully loaded.
			private function bossLoadHandler(e:OvpEvent):void {
				write("BOSS loaded successfully");
			}
			// Handles the notification that the BOSS feed was successfully parsed
			private function bossParsedHandler(e:OvpEvent):void {
				write("BOSS parsed successfully");
				var protocol:String = _bossFeed.versionOfMetafile == _bossFeed.METAFILE_VERSION_IV ? _bossFeed.protocol.indexOf("rtmpe") != -1 ? "rtmpe,rtmpte":"any":"any";
				startPlayback(_bossFeed.hostName,_bossFeed.streamName,_bossFeed.connectAuthParams,protocol);
			}
			// Commences connection to an ondemand stream
			private function startPlayback(hostname:String,streamname:String,authParams:String="",protocol:String = "any"):void {
				// The combination of hostname and authParams defines a unique key
				// which we can use to reference stored connections.
				_currentKey = hostname+authParams;
				_filename = streamname;
				// Close the current AkamaiConnection 
				if (_activeNC is AkamaiConnection) {
					if (_activeNC.isProgressive) {
						_ns.pause();
					} else {
						_ns.close();
					}
				}
				// If the required connection already exists, then use it
				if (_existingConnections[_currentKey]is AkamaiConnection) {
					_activeNC = _existingConnections[_currentKey];
					startUsingNC();
				} else {
					// Create a new AkamaiConnection
					var _nc:AkamaiConnection = new AkamaiConnection();
					
					_nc.addEventListener(OvpEvent.ERROR, errorHandler);
					_nc.addEventListener(OvpEvent.BANDWIDTH, bandwidthHandler);
					_nc.addEventListener(OvpEvent.STREAM_LENGTH, streamLengthHandler);
					_nc.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
										
					_nc.requestedProtocol = protocol;
					trace("requesting protocl" + _nc.requestedProtocol);
					if (authParams != "") {
						_nc.connectionAuth = authParams;
					}
					_nc.connect(hostname);
				}
			}
			// Once a good connection is found, this handler will be called
			private function connectedHandler(e:NetStatusEvent):void {
				_existingConnections[_currentKey] = AkamaiConnection(e.currentTarget);
				_activeNC = _existingConnections[_currentKey];
				write("Port: " + _activeNC.actualPort);
				write("Protocol: " + _activeNC.actualProtocol);
				write("IP address: " + _activeNC.serverIPaddress);
				startUsingNC();
			}
			// Start using new AkamaiConnection instance
			private function startUsingNC():void {
				bPlayPause.enabled = true;
				
				_ns = new AkamaiNetStream(_activeNC);

				// Use fastStart if you are sure the connectivity of your clients is at least
				// twice the bitrate of the video they will be viewing.
				_ns.useFastStartBuffer = true;

				_ns.addEventListener(OvpEvent.COMPLETE, endHandler); 
				_ns.addEventListener(OvpEvent.PROGRESS, update); 
				_ns.addEventListener(NetStatusEvent.NET_STATUS, streamStatusHandler);
				_ns.addEventListener(OvpEvent.NETSTREAM_PLAYSTATUS, streamPlayStatusHandler);
				_ns.addEventListener(OvpEvent.NETSTREAM_METADATA, metadataHandler);
				_ns.addEventListener(OvpEvent.NETSTREAM_CUEPOINT, cuepointHandler);
				_ns.addEventListener(OvpEvent.MP3_ID3, id3Handler);
				_ns.addEventListener(OvpEvent.STREAM_LENGTH, streamLengthHandler);
				_ns.maxBufferLength = 5;
				
				
				_video.attachNetStream(_ns);
				// Progressive streams don't connect to a streaming server and therefore can't measure bandwidth
				if (_currentDeliveryType == "video/x-flv") {
					bPlayPause.label = "PAUSE";
					_ns.play(_filename);
				} else {
					// Assume a streaming file and start the asynchronous process of requesting the stream length
					_activeNC.requestStreamLength(_filename);
					// Start the asynchronous process of estimating bandwidth. Only do this if 
					// bandwidth has not already been measured.
					if (isNaN(_measuredBandwidth)) {
						_activeNC.detectBandwidth();
					} else {
						bPlayPause.label = "PAUSE";
						_ns.play(_filename);
					}
				}
			}
			// Handles all error events for the connection and MediaRSS classes
			private function errorHandler(e:OvpEvent):void {
				write("Error #" + e.data.errorNumber + " " +e.data.errorDescription + " " + e.currentTarget);
				switch(e.data.errorNumber) {
					case OvpError.STREAM_NOT_FOUND:
						Alert.show("Connected to the server at " + _activeNC.serverIPaddress + " but timed-out trying to locate the live stream " + _filename, "UNABLE TO FIND STREAM ", Alert.OK);
						break;
					default:
						Alert.show("Error #" + e.data.errorNumber+": " + e.data.errorDescription, "ERROR", Alert.OK);
						break;
				} 
			}
			// Handles the result of the bandwidth estimate
			private function bandwidthHandler(e:OvpEvent):void {
				_measuredBandwidth = e.data.bandwidth;
				write("Bandwidth measured at " + e.data.bandwidth+ " kbps and latency is " + e.data.latency + " ms.");
				if (_mustSelectStream) {
					_mustSelectStream = false;
					playSelectedItem();
				} else {
					bPlayPause.label = "PAUSE";
					_ns.play(_filename);
				}
			}
			// Receives all status events dispatched by the active NetConnection
			private function netStatusHandler(e:NetStatusEvent):void {
				write(e.info.code);
				switch(e.info.code) {
					case "NetConnection.Connect.Success":
						connectedHandler(e);
						break;
					// If a connection closes due to a disconnect or idle timeut, then remove it
					// for the list of available connections
					case "NetConnection.Connect.Closed":
						var key:String = AkamaiConnection(e.target).hostName + "/" + AkamaiConnection(e.target).appNameInstanceName + AkamaiConnection(e.target).connectionAuth;
						delete _existingConnections[key];
					break;
				}

			}
			// Receives all status events dispatched by the active NetStream
			private function streamStatusHandler(e:NetStatusEvent):void {
				write(e.info.code);	
				if (e.info.code == "NetStream.Buffer.Full") {
					// _waitForSeek is used to stop the scrubber from updating
					// while the stream transtions after a seek
					_waitForSeek = false;
				}
			}
			// Receives all onPlayStatus events dispatched by the active NetStream
			private function streamPlayStatusHandler(e:OvpEvent):void {
				write(e.data.code);
			}
			// Here comes our id3 info in response to a request to getMp3Id3Info(name)
			private function id3Handler(e:OvpEvent):void {
				for (var i:String in e.data) {
					write("ID3: " + i + " " + e.data[i]);
				}
			}
			// Receives all onMetadata events dispatched by the active NetStream
			private function metadataHandler(e:OvpEvent):void {
				for (var propName:String in e.data) {
					write("metadata: "+propName+" = "+e.data[propName]);
				}
				// Adjust the video dimensions on the stage if they do not match the metadata
				if ((Number(e.data["width"]) != _video.width)  || (Number(e.data["height"]) != _video.height)) {
					scaleVideo(Number(e.data["width"]),Number(e.data["height"]));
				}
			}
			// Scales the video to fit into the 320x240 window while preserving aspect ratio.
			private function scaleVideo(w:Number,h:Number):void {
				if (w/h >= 4/3) {
					_video.width = 320;
					_video.height = 320*h/w;
				} else {
					_video.width = 240*w/h;
					_video.height = 240;
				}
				_video.x = (_videoHolder.width-_video.width)/2;
				_video.y = (_videoHolder.height-_video.height)/2;
			}
			// Receives all cuepoint events dispatched by the active NetStream
			private function cuepointHandler(e:OvpEvent):void {
				for (var propName:String in e.data) {
						if (propName != "parameters") {
							write(propName+" = "+e.data[propName]);
						} else {
							write("parameters =");
							if (e.data.parameters != undefined) {
								for (var paramName:String in e.data.parameters) {
									write(" "+paramName+": "+e.data.parameters[paramName]);
								}
							} else {
								write("undefined");
							}
						}
					}
			}
			// Handles the stream length response after a request to requestStreamLength
			private function streamLengthHandler(e:OvpEvent):void {
				write("Stream length is " + e.data.streamLength);
				slider.maximum = e.data.streamLength;
				slider.enabled = true;
				_streamLength = e.data.streamLength;
			}
			// Receives information that the end of stream has been reached
			private function endHandler(e:OvpEvent):void {
				write("End of stream detected.");
				playNext();
			}
   			// Plays the selected item in the tileList
   			private function playSelectedItem():void {
   				_playlistIndex = tileList.selectedIndex;
   				var item:ItemTO = ItemTO(tileList.selectedItem);
   				var url:String;
   				if (item && item.media.contentArray.length > 1) {
   					// Item has group tag, so we need to figure out the correct file to play based
   					// on the bandwidth measurement. We assume the content items are specified
   					// in an unknown order and therefore we must sort them first.
   					if (isNaN(_measuredBandwidth)) {
   						// Bandwidth has not yet been measured, but we only know bandwidth after connecting.
   						// Therefore, use the first item simply to connect and measure bandwdith and set a flag
   						// to revisit this selection routine once the bandwidth is known. 
   						url = item.media.getContentAt(0).url;
   						_mustSelectStream = true;
   					} else {
   						_mustSelectStream = false;
	   					var temp:Array  = new Array();
	   					for (var i:uint=0;i<item.media.contentArray.length;i++) {
	   						temp.push({index:i,bitrate:Number(item.media.getContentAt(i).bitrate.toString())});
	   					}
	   					// Default order will be lowest to highest after sort
	   					temp.sortOn(sortOnBitrate);
	   					url = item.media.getContentAt(0).url;
	   					slider.maximum = timecodeToSeconds(item.media.getContentAt(0).duration);
	   					for (var j:uint=0;j<item.media.contentArray.length;j++) {
	   						if ( _measuredBandwidth > 1.5*item.media.getContentAt(j).bitrate) {
	   							url = item.media.getContentAt(j).url;
	   							slider.maximum = timecodeToSeconds(item.media.getContentAt(j).duration);
	   						}	
	   					}
   					}
   	
   				} else {
   					slider.maximum = timecodeToSeconds(item.media.getContentAt(0).duration);
   					url = item.media.getContentAt(0).url;		
   				}
   				_currentDeliveryType = item.enclosure.type;
   				// At this stage, we branch for progressive/streaming playback
   					switch(_currentDeliveryType) {
   					// progressive
   					case "video/x-flv":
						slider.enabled = true;
						currentState = "progressive";
   						startPlayback("null",url);
   					break;
   					// Streaming
   					case "application/xml":
   						currentState = "";
   						_bossFeed.load(url);
   					break;
   					default:
   						Alert.show("The media item titled '" + item.media.title + "' did not contain a recognized type attribute.", "UNRECOGNIZED MEDIA ITEM TYPE IN RSS FEED", Alert.OK);
   					break;
   				}	  				
   			}
   			// Sort function for the bitrate array
   			private function sortOnBitrate(a:Object, b:Object):Number {
			    var aBit:Number = a["bitrate"];
			    var bBit:Number = b["bitrate"];
			    if(aBit> bBit) {
			        return 1;
			    } else if(aBit < bBit) {
			        return -1;
			    } else  {
			        return 0;
			    }
			}
			// Converts timecode to seconds
			private function timecodeToSeconds(timecode:String):Number {
				return Number(timecode.split(":")[0])*3600 + Number(timecode.split(":")[1])*60 + Number(timecode.split(":")[2]);
			}
   			// Plays the next item in the playlist.
   			private function playNext():void {
   				_playlistIndex = _playlistIndex + 1 >= _playlist.itemCount ? 0:_playlistIndex + 1;
   				tileList.selectedIndex = _playlistIndex;
   				playSelectedItem();		
   			}
   			// Updates the time display and slider
   			private function update(e:OvpEvent):void {
   				timeDisplay.text = _isLive ? _ns.timeAsTimeCode : _ns.timeAsTimeCode + "|"+ _activeNC.streamLengthAsTimeCode(_streamLength);
   				if (!_sliderDragging && !_waitForSeek && !_isLive) {
   					slider.value = _ns.time;
   				}
   				if (_currentDeliveryType == "video/x-flv") {
   					progressBar.setProgress(_ns.bytesLoaded,_ns.bytesTotal);
   				}
   			}
   			// Seeks the stream after the slider is dropped
   			private function doSeek():void {
   				_ns.seek(slider.value);
   			}
   			// Toggles the dragging state
   			private function toggleDragging(state:Boolean):void {
   				_sliderDragging = state;
   				if (!state) {
   					_waitForSeek = true;
   					doSeek();
   				}
   			}
   			// Handles play and pause
   			private function doPlayPause():void {
   				switch (bPlayPause.label){
   					case "PAUSE":
   					bPlayPause.label = "PLAY";
   					_ns.pause();
   					break;
   					case "PLAY":
   					bPlayPause.label = "PAUSE";
   					_ns.resume();
   					break;
   				}
   			}
   			// Formats the slider dataTip
			private function showVolume(val:String):String {
				return ("Volume: "+Math.round(Number(val)*100)+"%");
			}
			// Converts time to timecode
			private function showScrubTime(val:String):String {
	   			var sec:Number = Number(val);
				var h:Number = Math.floor(sec/3600);
				var m:Number = Math.floor((sec%3600)/60);
				var s:Number = Math.floor((sec%3600)%60);
				return (h == 0 ? "":(h<10 ? "0"+h.toString()+":" : h.toString()+":"))+(m<10 ? "0"+m.toString() : m.toString())+":"+(s<10 ? "0"+s.toString() : s.toString());
			}
			// Changes the stream volume
			private function changeVolume(event:SliderEvent):void {
				if (_activeNC is AkamaiConnection) _ns.volume = event.value;
			}
			// Writes trace statements to the output display
			private function write(msg:String):void {
				trace(msg);
			}
			
			private function onClickFilter(event:MouseEvent):void {
				if (filterText.text == "" || filterText.text == "*") {
					tileList.dataProvider = _playlist.itemArray;
					return;
				}
					
				var filterFields:RSSFilterFields = new RSSFilterFields();
				switch (rssFields.selectedValue.toString().toLowerCase())
				{
					case "title":
						filterFields.title = true;
						break;
					case "description":
						filterFields.description = true;
						break;
					case "all":
						filterFields.setAll(true);
						break;
				}
				
				var match:int = matchAnyOrAll.selectedValue.toString().toLowerCase() == "any" ? _playlist.FILTER_ANY : _playlist.FILTER_ALL;
				var startFilter:Number = getTimer();
				_filteredList = _playlist.filterItemList(filterText.text, filterFields, match);
				var endFilter:Number = getTimer();
				write("Filter method took "+(endFilter-startFilter)+"ms to execute.");			
				tileList.dataProvider = _filteredList;
			}
		]]>
	</mx:Script>
	<mx:states>
		<mx:State name="progressive">
			<mx:AddChild relativeTo="{slider}" position="before">
				<mx:ProgressBar width="320" labelPlacement="center"  mode="manual" id="progressBar" minimum="0" indeterminate="false"/>
			</mx:AddChild>
		</mx:State>
	</mx:states>
	
	<mx:HBox left="14" top="90" right="19" height="400" horizontalScrollPolicy="off" verticalScrollPolicy="off">
		<mx:Canvas width="340" height="346" backgroundAlpha="0.09" backgroundColor="#000000">
			<mx:VBox x="0" y="0" height="100%" width="100%" borderStyle="none" horizontalAlign="center" verticalAlign="middle" id="vbox1">
			  <mx:HBox width="320" height="240" id="videoWindow" borderStyle="none" verticalAlign="middle" horizontalAlign="center" backgroundColor="#000000"/>   	
			  <mx:HSlider allowTrackClick="true" id="slider" enabled="false" dataTipFormatFunction="showScrubTime" thumbPress="toggleDragging(true)" thumbRelease="toggleDragging(false)"       width="320"/>
			  <mx:ApplicationControlBar width="320" id="applicationcontrolbar1">
			  	     <mx:Button id="bPlayPause" label="PAUSE" click="doPlayPause()" enabled="false"/>
			  	     <mx:Spacer width="100%"  height="28"/>
			  	     <mx:HSlider width="56" height="20" id="volumeSlider"  value="100" dataTipFormatFunction="showVolume" minimum="0" maximum="1" change="changeVolume(event)" allowTrackClick="true"   liveDragging="true"/>
			  	     <mx:Spacer width="10" height="28"/>
			  	     <mx:Text id="timeDisplay"  text="00:00|00:00" styleName="strong"/>
			  </mx:ApplicationControlBar>
			</mx:VBox>
		</mx:Canvas>
		<mx:VBox height="100%" width="100%">
			<mx:VBox id="filterContainer" visible="false" includeInLayout="false">		
				<mx:HBox>
					<mx:VBox>
						<mx:Label text="Filter Text" />
						<mx:TextInput id="filterText" />
					</mx:VBox>
					<mx:VBox>
						<mx:Label />
						<mx:Button id="bFilter" label="FILTER" click="onClickFilter(event)" />
					</mx:VBox>
					<mx:VBox paddingLeft="12">
						<mx:Label text="RSS Fields" />
						<mx:HBox>
							<mx:RadioButtonGroup id="rssFields" />
							<mx:RadioButton label="Title" groupName="rssFields"/>
							<mx:RadioButton label="Description" groupName="rssFields" />
							<mx:RadioButton label="All" groupName="rssFields" selected="true" />
						</mx:HBox>
					</mx:VBox>
					<mx:VBox paddingLeft="12">
						<mx:Label text="Match" />
						<mx:HBox>
							<mx:RadioButtonGroup id="matchAnyOrAll" />
							<mx:RadioButton label="Any" groupName="matchAnyOrAll" selected="true" />
							<mx:RadioButton label="All" groupName="matchAnyOrAll" />
						</mx:HBox>
					</mx:VBox>
				</mx:HBox>
				<mx:HRule width="100%" />
			</mx:VBox>		
			<mx:VBox verticalScrollPolicy="auto" height="100%" width="100%">
				<mx:TileList width="100%"   change="playSelectedItem()" rollOverColor="0x444444"  selectionColor="0x666666" height="100%" id="tileList"
					backgroundAlpha="0.0" borderStyle="none" verticalScrollPolicy="auto">
				 <mx:itemRenderer>
		            <mx:Component>
		                <mx:VBox  backgroundColor="0x3a3a3a" horizontalAlign="center" width="150" height="150">
		                   <mx:Text id="albumName" width="120" text="{data.title}" />
		                   <mx:Image id="albumImage"  width="120" height="90" source="{data.media.thumbnail.url}"/>
		                </mx:VBox>
		            </mx:Component>
		         </mx:itemRenderer>
				</mx:TileList>
			</mx:VBox>
		</mx:VBox>
	</mx:HBox>
	<mx:Label x="14" y="10" text="Akamai MediaRSS Reference Player" styleName="title"/>
	<mx:TextInput x="13" y="48" width="601" id="playlistPath" />
	<mx:Button x="620" y="48" id="bLoad" label="LOAD" click="_playlist.load(playlistPath.text)" width="63"/>
	<mx:Label x="11" y="32" text="Enter the path to the StreamOS MediaRSS playlist and then press the LOAD button"/>
</mx:Application>

