<?xml version="1.0" encoding="utf-8"?>
<!--
//
// Copyright (c) 2009, the Open Video Player authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without 
// modification, are permitted provided that the following conditions are 
// met:
//
//    * Redistributions of source code must retain the above copyright 
//		notice, this list of conditions and the following disclaimer.
//    * Redistributions in binary form must reproduce the above 
//		copyright notice, this list of conditions and the following 
//		disclaimer in the documentation and/or other materials provided 
//		with the distribution.
//    * Neither the name of the openvideoplayer.org nor the names of its 
//		contributors may be used to endorse or promote products derived 
//		from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
-->
<mx:Application xmlns:mx="http://www.adobe.com/2006/mxml" clipContent="false"  layout="absolute" applicationComplete="init()" width="100%" height="100%"  verticalAlign="middle" horizontalAlign="center" viewSourceURL="srcview/index.html">

<!-- 
This player is designed to play Stream OS content links, including on-demand streaming,
live streaming and progressive playback.
-->

	<mx:Script>
		<![CDATA[
			import mx.events.ResizeEvent;
			import mx.core.UIComponent;
			import mx.events.SliderEvent;
			import mx.controls.Alert;
			import flash.geom.*; 
			import flash.events.FullScreenEvent;
			import flash.display.Stage;
			import flash.display.StageDisplayState;
			import flash.display.LoaderInfo;
			
			import org.openvideoplayer.events.*;
			import org.openvideoplayer.net.*;
			import org.openvideoplayer.rss.*;
			
			import com.akamai.net.*;
			import com.akamai.rss.*;
			
			// Define private variables
			private var _nc:AkamaiConnection;
			private var _ns:AkamaiNetStream;
			private var _bossMetafile:AkamaiBOSSParser;
			private var _sliderDragging:Boolean;
			private var _waitForSeek:Boolean;
			private var _video:Video;
			private var _videoHolder:UIComponent;
			private var _bandwidthMeasured:Boolean;
			private var _hasEnded:Boolean;
			private var _videoSettings:Object;
			private var _path:String;
			private var _timer:Timer;
			private var _isLive:Boolean;
			private var _streamLength:Number;
			
			[Bindable]
			private var status:String;
			
			// You may use these sample links to test your own implementation of this code.
			private const SAMPLES:Array = [
								{label:"Metafile version I",data:"http://products.edgeboss.net/flash/products/mediaframework/fms/0223_quikpro_highlights_700.flv?xmlvers=1"},
								{label:"Metafile version II",data:"http://products.edgeboss.net/flash/products/mediaframework/fms/akamai_10ya_nab_700k.flv?xmlvers=2"},
								{label:"Progressive sample 1",data:"http://products.edgeboss.net/download/products/mediaframework/fms/0223_quikpro_lgwaveoftheday_web_700.flv"}
								];
								
			
			// Define functions
			private function init():void {
				_isLive = false;
				
				// Instantiate the metafile parser
				_bossMetafile = new AkamaiBOSSParser();
				_bossMetafile.addEventListener(OvpEvent.PARSED,bossParsedHandler);
				_bossMetafile.addEventListener(OvpEvent.LOADED,bossLoadHandler);
				_bossMetafile.addEventListener(OvpEvent.ERROR,errorHandler);
				// Instantiate the connectin class
				_nc = new AkamaiConnection();
				_nc.addEventListener(OvpEvent.ERROR,errorHandler);
				_nc.addEventListener(OvpEvent.STREAM_LENGTH,streamLengthHandler); 
				_nc.addEventListener(NetStatusEvent.NET_STATUS,netStatusHandler);

				
				_bandwidthMeasured = false;
				addVideoToStage();
				// Initialize various properties and handlers
				stage.addEventListener(Event.RESIZE,handleResize);
				stage.addEventListener(FullScreenEvent.FULL_SCREEN,handleReturnFromFullScreen);
				_timer = new Timer(500,1);
				_timer.addEventListener(TimerEvent.TIMER_COMPLETE,scaleVideo);
				_path = loaderInfo.parameters.url == undefined ? this.SAMPLES[0].data : loaderInfo.parameters.url;
				// Start the ball rolling
				startPlayback();	
			}	
			// Commences connection to a new link
			private function startPlayback():void {
				status = "LOADING";
				bPlayPause.enabled = false;
				bFullscreen.enabled = false;
				_hasEnded = false;
				// Clean up from previous session, if it exists
				if (_nc.netConnection is NetConnection) {
					if (_isLive) {
						//_ns.unsubscribe();
					}
					_ns.useFastStartBuffer = false;
					_nc.close();
				}
				// Decide if the link will return a BOSS xml metafile, or if it is
				// a direct reference to a progressive FLV file. Note that we err
				// on the side of progressive, to allow you to use this player
				// to play progressive links from any HTTP source. 
				if (_path == "") {
					Alert.show("No Stream OS source has been specified", "ERROR", Alert.OK);
				} else {
					if (_path.split("/").length > 3 && _path.split("/")[3].toUpperCase() == "DOWNLOAD") {
						_nc.connect(null); 
					} else {
						_bossMetafile.load(_path);
					}
				}
				
			}
			// Handles the notification that the BOSS feed was successfully loaded.
			private function bossLoadHandler(e:OvpEvent):void {
				write("BOSS loaded successfully");
			}
			// Handles the notification that the BOSS feed was successfully parsed
			private function bossParsedHandler(e:OvpEvent):void {
				write("BOSS parsed successfully:");
				write("========== Metafile data ==============");
				switch (_bossMetafile.versionOfMetafile) {
					case _bossMetafile.METAFILE_VERSION_I:
						write("  Server name: " + _bossMetafile.serverName);
						write("  Fallback server name: " + _bossMetafile.fallbackServerName);
						write("  App name: " + _bossMetafile.appName);
						write("  Stream name: " + _bossMetafile.streamName);
						write("  Is live: " + _bossMetafile.isLive);
						write("  Buffer time: " + _bossMetafile.bufferTime);
						_nc.requestedProtocol = "any";
					break;
					case _bossMetafile.METAFILE_VERSION_II:
						write("  Server name: " + _bossMetafile.serverName);
						write("  App name: " + _bossMetafile.appName);
						write("  Stream name: " + _bossMetafile.streamName);
						write("  Is live: " + _bossMetafile.isLive);
						write("  Buffer time: " + _bossMetafile.bufferTime);
						_nc.requestedProtocol = "any";
					break;
					case _bossMetafile.METAFILE_VERSION_IV:
						write("  Server name: " + _bossMetafile.serverName);
						write("  App name: " + _bossMetafile.appName);
						write("  Stream name: " + _bossMetafile.streamName);
						write("  Is live: " + _bossMetafile.isLive);
						write("  Title: " + _bossMetafile.title);
						write("  Source: " + _bossMetafile.source);
						write("  Author: " + _bossMetafile.author);
						write("  Clip begin: " + _bossMetafile.clipBegin);
						write("  Clip end: " + _bossMetafile.clipEnd);
						write("  Duration: " + _bossMetafile.duration);
						write("  Connect Auth Params: " + _bossMetafile.connectAuthParams);
						write("  Play Auth Params: " + _bossMetafile.playAuthParams);
						write("  Secondary Encoder Source: " + _bossMetafile.secondaryEncoderSrc);
						write("  Keywords: " + _bossMetafile.keywords);
						_nc.requestedProtocol = _bossMetafile.protocol.indexOf("rtmpe") != -1 ? "rtmpe,rtmpte":"any";
					
					break;
				}
				write("======= End of Metafile data ===========");
				// Establish the connection
				trace("requested protocl set to " + _nc.requestedProtocol);
				_nc.connectionAuth = _bossMetafile.connectAuthParams;
				_isLive = _bossMetafile.isLive;
				_nc.connect(_bossMetafile.hostName); 
			}
			// Once a good connection is found, this handler will be called
			private function connectedHandler():void {
				_ns = new AkamaiNetStream(_nc.netConnection);
				
				_ns.liveStreamAuthParams = _bossMetafile.playAuthParams;
				
				_ns.addEventListener(OvpEvent.STREAM_LENGTH, streamLengthHandler); 
				_ns.addEventListener(OvpEvent.COMPLETE, completeHandler); 
				_ns.addEventListener(OvpEvent.PROGRESS, update); 
				_ns.addEventListener(NetStatusEvent.NET_STATUS, streamStatusHandler);
				_ns.addEventListener(OvpEvent.NETSTREAM_PLAYSTATUS, streamPlayStatusHandler);
				_ns.addEventListener(OvpEvent.NETSTREAM_METADATA, metadataHandler);
				_ns.addEventListener(OvpEvent.NETSTREAM_CUEPOINT, cuepointHandler);
				
				_ns.maxBufferLength = 2;
				
				_video.attachNetStream(_ns);
				// Branchbased on the playback mode
				if (_nc.isProgressive) {
					currentState = "progressive";
					write("Progressive connection established");
					playVideo(_path);
				} else {
					currentState = _bossMetafile.isLive ? "live":"";
					write("Successfully connected to: " + _nc.netConnection.uri);
					write("Port: " + _nc.actualPort);
					write("Protocol: " + _nc.actualProtocol);
					write("Server IP address: " + _nc.serverIPaddress);
					// If an ondemand stream, start the asynchronous process of requesting the stream length 
					if (!_isLive) {
						_nc.requestStreamLength(_bossMetafile.streamName);
					}
					_ns.useFastStartBuffer = !_isLive;
					playVideo(_bossMetafile.streamName);
				}
			}
			// Handles all error events
			private function errorHandler(e:OvpEvent):void {
				switch(e.data.errorNumber) {
				case OvpError.STREAM_NOT_FOUND:
					Alert.show("Connected to the server at " + _nc.serverIPaddress + " but timed-out trying to locate the live stream " + _bossMetafile.streamName, "UNABLE TO FIND STREAM ", Alert.OK);
					break;
				case OvpError.STREAM_BUFFER_EMPTY:
					// Don't display this error - it is only a warning about the netstream buffer remaining empty
				default:
					Alert.show("Error #" + e.data.errorNumber+": " + e.data.errorDescription, "ERROR", Alert.OK);
					break;
				}
			}
			// Receives all status events dispatched by the active NetConnection
			private function netStatusHandler(e:NetStatusEvent):void {
				write(e.info.code);
				switch (e.info.code) {
					case "NetConnection.Connect.Rejected":
						write("Rejected by server. Reason is "+e.info.description);
						break;
					case "NetConnection.Connect.Success":
						connectedHandler();
						break;
				}
			}
			// Receives all status events dispatched by the active NetStream
			private function streamStatusHandler(e:NetStatusEvent):void {
				write(e.info.code);	
				switch (e.info.code) {
					case "NetStream.Buffer.Full":
						// _waitForSeek is used to stop the scrubber from updating
						// while the stream transtions after a seek
						_waitForSeek = false;
						// Rescale the video
						scaleVideo(null);
						// Set the status
						status = "PLAYING";
					break;
					case "NetStream.Pause.Notify":
						status = "PAUSED";
					break;
					case "NetStream.Play.Start":
						status = "BUFFERING";
					break;
					case "NetStream.Seek.Notify":
						status = "SEEKING";
					break;
				}
			}
			// Receives all onPlayStatus events dispatched by the active NetStream
			private function streamPlayStatusHandler(e:OvpEvent):void {
				write(e.data.code);
			}
			// Handles a successfull subscription to a live stream
			private function subscribedHandler(e:OvpEvent):void {
				write("Successfully subscribed to the live stream");
			}
			// Handles unsubscription form a live stream
			private function unsubscribedHandler(e:OvpEvent):void {
				write("Unubscribed from the live stream");
				bPlayPause.enabled = false;
				bFullscreen.enabled = false;
				cbVideoScaleMode.enabled = false;
			}
			// Notifies the user that the class is making another attempt to subscribe to a live stream
			private function subscribeAttemptHandler(e:OvpEvent):void {
				write("Attempting to subscribe to the live stream ...");
				status="SUBSCRIBING TO LIVE STREAM ..."
			}
			// Receives all onMetadata events dispatched by the active NetStream
			private function metadataHandler(e:OvpEvent):void {
				write("========== Metadata found in stream  ===========");
				for (var propName:String in e.data) {
					write("  "+propName+" = "+e.data[propName]);
				}
				write("========== End of Stream Metadata  ===========");
			}
			// Scales the video to fit into the 320x240 window while preserving aspect ratio.
			private function scaleVideo(e:Event):void {
				switch (cbVideoScaleMode.selectedItem.label) {
					case "Fit":
						if (_video.videoWidth/_video.videoHeight >= videoBackground.width/videoBackground.height) {
							_video.width = videoBackground.width;
							_video.height = videoBackground.width*_video.videoHeight/_video.videoWidth;
						} else {
							_video.width = videoBackground.height*_video.videoWidth/_video.videoHeight;
							_video.height = videoBackground.height;
						}
						_videoHolder.mask = null;
						break;
					case "Stretch":
						_video.width = videoBackground.width;
						_video.height = videoBackground.height;
						_videoHolder.mask = null
						break;
					case "Native":
						_video.width = _video.videoWidth;
						_video.height = _video.videoHeight;
						_videoHolder.mask = (_video.width > videoBackground.width || _video.height> videoBackground.height) ? videoBackground:null;
						break;
				}
				_video.x = 5 + ((videoBackground.width - _video.width)/2);
				_video.y = 5 + ((videoBackground.height- _video.height)/2);
				// The video element was hidden at the start so that users do not see it resize from the default size of 320x240 to its scaled size
				_video.visible = true;
				
			}
			// Receives all cuepoint events dispatched by the active NetStream
			private function cuepointHandler(e:OvpEvent):void {
				for (var propName:String in e.data) {
						if (propName != "parameters") {
							write(propName+" = "+e.data[propName]);
						} else {
							write("parameters =");
							if (e.data.parameters != undefined) {
								for (var paramName:String in e.data.parameters) {
									write(" "+paramName+": "+e.data.parameters[paramName]);
								}
							} else {
								write("undefined");
							}
						}
					}
			}
			// Handles the stream length response after a request to requestStreamLength
			private function streamLengthHandler(e:OvpEvent):void {
				write("Stream length is " + e.data.streamLength);
				slider.maximum = e.data.streamLength;
				slider.enabled = true;
				_streamLength = e.data.streamLength;
			}
			// Receives information that stream playback is complete. This notification
			// should not be used when playing back progressive content as the Flash client
			// does not dispatch the NetStream.onPlayStatus event on which this notification is based.
			private function completeHandler(e:OvpEvent):void {
				write("Stream is complete");
				_hasEnded = true;
				status = "ENDED";
				bPlayPause.label = "PLAY";
			}
			// Attaches the video to the stage
			private function addVideoToStage():void {
				_videoHolder= new UIComponent();
				_video = new Video();
				_video.smoothing = true;
				_videoHolder.addChild(_video);
				addChild(_videoHolder);
				_video.visible = false;
   			}
   			// Plays the stream 
   			private function playVideo(name:String):void {
   				_ns.play(name);
   				bPlayPause.label = "PAUSE";  
   				bPlayPause.enabled = true;
				bFullscreen.enabled = true;
				cbVideoScaleMode.enabled = true;				
   			}
   			// Updates the time display and slider
   			private function update(e:OvpEvent):void {
   				timeDisplay.text = _isLive ? _ns.timeAsTimeCode + " [Live]": _ns.timeAsTimeCode + "|"+ _nc.streamLengthAsTimeCode(_streamLength);
   				if (!_isLive) {
   					if (!_sliderDragging && !_waitForSeek) {
   						slider.value=_ns.time;
   					}
   				}
   				if (_nc.isProgressive) {
   					progressBar.setProgress(_ns.bytesLoaded, _ns.bytesTotal);
   				}
   				status = status.indexOf("BUFFERING") != -1 ? "BUFFERING " + Math.min(100,Math.round(_ns.bufferLength*100/_ns.bufferTime))+"%":status;
   			}
   			// Seeks the stream after the slider is dropped
   			private function doSeek():void {
   				write("calling seek to " + slider.value);
   				if (_hasEnded) {
   					_hasEnded = false;
   					_ns.play(_nc.isProgressive ? _path: _bossMetafile.streamName);
   					bPlayPause.label = "PAUSE";
   				} 
   				_ns.seek(slider.value);
   			}
   			// Toggles the dragging state
   			private function toggleDragging(state:Boolean):void {
   				_sliderDragging = state;
   				if (!state) {
   					_waitForSeek = true;
   					doSeek();
   				}
   			}
   			// Handles play and pause
   			private function doPlayPause():void {
   				switch (bPlayPause.label){
   					case "PAUSE":
   						bPlayPause.label = "PLAY";
   						_ns.pause();
   					break;
   					case "PLAY":
   						bPlayPause.label = "PAUSE";
   						if (_hasEnded) {
   							_hasEnded = false;
   							_ns.play(_nc.isProgressive ? _path: _bossMetafile.streamName);
   						} else {
   							_ns.resume();
   						}
   					break;
   				}
   			}
   			// Formats the slider dataTip
			private function showVolume(val:String):String {
				return ("Volume: "+Math.round(Number(val)*100)+"%");
			}
			// Converts time to timecode
			private function showScrubTime(val:String):String {
	   			var sec:Number = Number(val);
				var h:Number = Math.floor(sec/3600);
				var m:Number = Math.floor((sec%3600)/60);
				var s:Number = Math.floor((sec%3600)%60);
				return (h == 0 ? "":(h<10 ? "0"+h.toString()+":" : h.toString()+":"))+(m<10 ? "0"+m.toString() : m.toString())+":"+(s<10 ? "0"+s.toString() : s.toString());
			}
			// Changes the stream volume
			private function changeVolume(event:SliderEvent):void {
				if (_nc is AkamaiConnection) 
					_ns.volume = event.value;
			}
			// Handle resize and avoid rescaling video too quickly
			private function handleResize(e:Event):void {
				if (stage["displayState"] != StageDisplayState.FULL_SCREEN) {
					_timer.reset();
					_timer.start();
				};
			}
			// Aggregates trace statements - you may use this function
			// to write to screen if you need to debug
			private function write(msg:String):void {
				trace(msg);
			}
			// Switches to full screen mode
			private function switchToFullScreen():void {
				try {
				    // Save the old values
				    _videoSettings = new Object();
				    _videoSettings.savedWidth = _video.width;
				    _videoSettings.savedHeight = _video.height;
		    		_videoSettings.x = _video.x;
				    _videoSettings.y = _video.y;
				  	// Set new values
				    stage["fullScreenSourceRect"] = new Rectangle(0,0, _video.videoWidth ,_video.videoHeight);
				    stage["displayState"] = StageDisplayState.FULL_SCREEN;
				    _video.width =  _video.videoWidth;
				    _video.height =  _video.videoHeight;
				    _video.smoothing = false;
				    _video.x = -_videoHolder.width/2;
				    _video.y = -_videoHolder.height/2;
				}
				catch (e:Error) {
					write ("Fullscreen has not been enabled in the HTML");
				}
			}
			// Handles the return from fullscreen
			private function handleReturnFromFullScreen(e:FullScreenEvent):void {
				if (!e.fullScreen) {
					_video.width = _videoSettings.savedWidth;
				    _video.height = _videoSettings.savedHeight;
				    _video.smoothing = true;
				    _video.x = _videoSettings.x;
				    _video.y = _videoSettings.y;
				} 
			}
		]]>
	</mx:Script>
	<mx:states>
		<mx:State name="progressive">
			<mx:AddChild relativeTo="{canvas1}" position="firstChild">
					<mx:ProgressBar id="progressBar" x="7" y="-2" width="{slider.width-12}" label="" mode="manual" minimum="0" maximum="1" height="12"/>
			</mx:AddChild>
		</mx:State>
		<mx:State name="live">
			<mx:RemoveChild target="{canvas1}"/>
			<mx:AddChild relativeTo="{timeDisplay}" position="before">
				<mx:Spacer width="100%"/>
			</mx:AddChild>
		</mx:State>
	</mx:states>
	
	   
	<mx:VBox borderStyle="none" clipContent="false" horizontalAlign="center" verticalAlign="middle" id="vbox1" left="5" top="5" bottom="5" right="5">
	  <mx:HBox width="100%" height="100%" id="videoBackground" clipContent="false" borderStyle="none"  verticalAlign="middle" horizontalAlign="center" backgroundColor="#000000"/>   	
	  <mx:HBox width="100%"  verticalAlign="middle" id="hbox1">
	  	<mx:Canvas width="100%" id="canvas1">
	  		<mx:HSlider x="0" allowTrackClick="true" id="slider" enabled="false" dataTipFormatFunction="showScrubTime" thumbPress="toggleDragging(true)" thumbRelease="toggleDragging(false)"       width="100%"/>
	  	</mx:Canvas>
	  	 <mx:Text id="timeDisplay"  text="00:00|00:00"  fontWeight="bold" fontSize="12"/>
	  </mx:HBox>
	 	<mx:ApplicationControlBar width="100%" id="applicationcontrolbar1">
	  	     <mx:Button id="bPlayPause" label="PAUSE" click="doPlayPause()" enabled="false"/>
	  	     <mx:Button id="bFullscreen" label="FULLSCREEN" click="switchToFullScreen()"  enabled="false"/>
	  	     <mx:ComboBox id="cbVideoScaleMode"  change="scaleVideo(event)" selectedIndex="2" width="81" enabled="false">
	  	     	<mx:dataProvider>
	  	     	 <mx:Array>
	  	     	     <mx:Object label="Fit" />
	  	     	     <mx:Object label="Stretch" />
	  	     	     <mx:Object label="Native" />
	  	     	 </mx:Array>
	  	     	</mx:dataProvider>
	  	     </mx:ComboBox>
	  	     <mx:Label text="{status}"/>
	  	     <mx:Spacer width="100%" id="spacer1"/>
	  	     <mx:HSlider width="46" height="12" id="volumeSlider"  value="100" dataTipFormatFunction="showVolume" minimum="0" maximum="1" change="changeVolume(event)" allowTrackClick="true"   liveDragging="true"/>
	  	</mx:ApplicationControlBar>
	</mx:VBox>

		


</mx:Application>
